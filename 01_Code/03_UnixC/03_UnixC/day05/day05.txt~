复习：
1.内存管理相关的函数
1.1 使用malloc申请内存
    使用malloc申请内存时，除了指定的内存空间之外，还可能额外申请12个字节存储管理内存的相关信息,使用malloc申请的内存时，不要进行越界操作，以免带来非法内存访问错误
    使用malloc申请比较小的内存时，一般系统会分配33个内存页,再使用malloc申请内存时，会在33个内存页的范围内进行分配
    getchar() - 获取一个字符
    getpid() - 获取进程号
    cat /proc/进程号/maps - 查看进程的内存分配情况

1.2 使用free释放内存
    使用free释放内存时，释放多少则减去多少,当所有内存释放完毕后，系统可能保留33个内存页备用

1.3 sbrk函数 -> 申请/释放动态内存,更多的用于申请内存
    brk函数 -> 申请/释放动态内存,更多的用于释放内存

1.4 mmap函数 -> 建立到物理内存/文件/设备的映射
    munmap函数 -> 解除映射

2.文件操作
2.1 文件概念
   在unix/linux系统中,把一切都可以看做文件,包括目录和设备等等
   /dev/null -> 空设备
   /dev/tty - 输入输出设备
   /dev/console - 控制台设备

   echo hello > /dev/null  丢弃
   cat /dev/null > a.txt   清空文件

2.2 相关函数
   open() - 打开/创建文件
   close() - 关闭文件
   read() - 读取文件中的内容
   write() - 写入数据到文件
-------------------------------------------------------
今天内容：
    (1)文件的相关操作
1.文件的相关操作
1.1 文件的读写操作
(1)读写函数使用
    open()/close()/read()/write()

练习：
   编写03writeemp.c文件，定义一个员工变量并且初始化，将该员工信息写入到文件emp.dat中,员工信息有：员工ID,姓名,薪水; 再编写一个03reademp.c文件，将文件emp.dat中的员工信息读取出来，然后打印出来

(2)lseek函数
   #include <sys/types.h>
   #include <unistd.h>
   off_t lseek(int  fd,  off_t  offset,int whence);
第一个参数：文件描述符
第二个参数：偏移量
第三个参数：从什么地方开始偏移
    SEEK_SET - 文件开头
    SEEK_CUR - 当前位置
    SEEK_END - 文件末尾,文件中最后一个元素的下一个位置
返回值：
    成功返回当前位置到文件开头的偏移量，失败返回-1
函数功能：
    表示将fd指向的文件中读写位置修改到从whence偏移offset个字节的位置上

1.2 文件描述符的概念
   文件描述符本质就是一个非负整数,可以代表一个打开的文件,但是文件的信息并不是存放在文件描述符中，而是存在文件表中,当使用open函数打开文件时，会将文件的相关信息存放到文件表中,但是出于安全和效率等因素的考虑，文件表不适合直接操作，而是给文件表对应一个编号，使用该编号进行操作，这个编号就是文件描述符
   每个进程都有一张描述符总表,当有新的描述符需求时，会取总表中查找未使用的最小值返回,文件描述符从0开始,其中0 1 2被系统占用，分别代表标准输入，标准输出和标准错误,所以一般都是从3开始使用
   调用close函数本质就是解除描述符和文件表的对应关系

1.3 文件操作比较
标C：fopen()/fclose()/fread()/fwrite()
UC： open()/close()/read()/write()

例子：
   分别使用标C函数和UC函数来实现向二进制文件中写入0~100万之间的数

总结：
   标C函数都有输入输出的缓冲区,会积累一定数量之后再执行读写操作，依次效率比较高;而UC函数虽然在内核层也有小型的缓冲区，但是和标C函数相比读写效率比较低
   使用命令 time 可以查看程序的运行时间
   可以通过自定义缓冲区来提供UC函数的效率
如：
   1000斤 散装苹果   1个苹果 10个苹果  100个苹果 
                     20斤手提袋搬苹果     

1.4 dup/dup2函数
   #include <unistd.h>
   int dup(int oldfd);
   int dup2(int oldfd, int newfd);
函数功能：
   表示对参数oldfd指定的文件描述符做拷贝，如果成功通过返回值返回，失败返回-1,对dup2来说，参数newfd为指定的文件描述符

1.5 fcntl函数(重要复杂)
(1)整体介绍
   #include <unistd.h>
   #include <fcntl.h>
   int fcntl(int fd, int cmd, ... /* arg */ );
第一个参数：文件描述符，表示对哪个文件操作
第二个参数：操作命令，表示进行什么样的操作
    F_DUPFD - 复制文件描述符,第三个参数指定新文件描述
        符,与dup2不同的是,寻找大于等于arg的最小描述符
        ,不会强制占用已经被使用的文件描述符
    F_GETFD/F_SETFD - 获取/设置文件描述符标志
    F_GETFL/F_SETFL - 获取/设置文件状态标志
    F_SETLK/F_SETLKW/F_GETLK - 加锁/解锁/判断锁是否存在
第三个参数：可变长参数，是否需要取决于cmd
    实现文件锁功能时的第三个参数类型为指向以下结构体的指针类型，结构体类型说明如下：
    struct flock 
    {
        ...
        short l_type;/*锁的类型:F_RDLCK 读锁, F_WRLCK 写锁, F_UNLCK 解锁*/
        short l_whence;/*锁定起始位置 SEEK_SET 开始位置, SEEK_CUR 当前位置, SEEK_END 结尾位置*/
        off_t l_start; /*偏移量*/
        off_t l_len; /*锁定的字节数*/
        pid_t l_pid;/*加锁的进程号(F_GETLK only),给-1*/
        ...
    };

函数功能：
    a.复制文件描述符
    b.获取/设置 文件描述符标志/文件状态标志 的信息
    c.文件锁的功能(重点)

(2)文件锁的介绍
   当多个进程同时读写文件时,可能引发文件内容的混乱,如果所有的进程都是读文件,是可以同时进程;但是如果有一个进程进行写文件操作,那么其他进程就应该等待，也就是说多个进程串行工作，采用文件锁解决此问题
    文件锁本质就是读写锁:一把读锁和一把写锁;其中读锁是一把共享锁，也就是允许其他进程加读锁，但不允许加写锁;而写锁是一把互斥锁,不允许其他进程加读锁和写锁

(3)使用fcntl函数实现文件锁的功能
a.F_SETLK - 设置读锁/设置写锁/解锁
  成功返回0,失败返回-1

明日预报：
   (1)文件操作
   (2)目录操作
   (3)进程和多进程的初识


















































