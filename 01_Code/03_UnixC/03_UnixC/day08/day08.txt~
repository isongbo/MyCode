复习：
1.进程和多进程
1.1 进程的基本概念和命令
   程序：存放在硬盘上的可执行文件
   进程：运行在内存中的程序
   ps  - 查看当前终端的进程
   ps -aux | more 表示显示所有包括其他使用者的进程
   ps -ef | more  表示以全格式的方式去显示进程
   kill -9 进程号 表示杀死指定的进程

   操作系统支持多进程的,如果进程A启动了进程B,那么就说进程A叫做进程B的父进程，进程B叫做进程A的子进程
   一般来说，进程0启动了进程1(init)和进程2,其他所有进程都是由进程1和进程2直接/间接的启动起来

1.2 各种id
   PID - 进程号,进程的唯一标识,延迟重用
   getpid() - 获取当前进程的进程号
   getppid() - 获取当前进程的父进程PID
   getuid() - 获取用户ID
   getgid() - 获取组ID
   
1.3 进程的创建
(1)fork函数
   表示以复制当前进程的方式来创建一个新的进程

(2)父子进程的执行流程
   a.对于fork之前的代码,父进程执行一次
   b.对于fork之后的代码,父子进程各自执行一次
   c.fork有两个返回值,子进程返回0,父进程返回子进程PID

(3)父子进程的资源关系
   子进程复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享

(4)父子进程的相互影响
   a.子进程先结束,子进程会给父进程发信号,由父进程帮助回收资源
   b.如果父进程先结束,子进程变成孤儿进程,变更父进程为init进程,init进程叫做孤儿院
   c.如果子进程结束，父进程由于各种原因没有受到子进程信号,子进程变成僵尸进程

1.3 进程的终止
正常终止方式：
   a.在main函数执行了return 0
   b.调用exit函数
   c.调用_exit()/_Exit()函数
   d.最后一个线程返回
   e.最后线程调用pthread_exit函数
非正常终止方式：
   a.采用信号终止进程
   b.最后一个线程被其他线程取消

   _exit() - UC函数,立即结束
   _Exit() - 标C函数,立即结束
   exit() - 调用atexit注册的函数

1.4 进程的等待
   wait() - 表示等待任意一个子进程状态发生改变
   waitpid() - 表示等待指定的子进程状态发生改变

1.5 其他相关函数
   vfork() - 创建子进程
   execl() - 执行指定的功能代码,类似于跳转
   system() - 执行具体的shell命令/可执行文件
-------------------------------------------------------
今天内容：
   (1)中断的概念和分类
   (2)信号的概念和处理

1.中断的概念和分类
1.1 概念
  中断：表示中止当前正在执行的工作，转而取执行新的进程,或者处理意外的情况，叫做中断

1.2 中断的分类
  中断分为两种：硬件中断 + 软件中断

2.信号的概念和处理
2.1 概念
  信号本质就是一个软件中断
比如 
   ctrl+c 就是发送了一个信号
   kill -9 发送了一个信号
   段错误 也就是一个信号

   kill -l 表示查看当前系统支持的信号
   信号本质就是整数值,信号的名称都是以SIG开头,其中linux系统一般表示的信号范围是：1 ~ 64,unix系统一般表示的信号范围是1~48之间

掌握的信号：
    ctrl+c   SIGINT   2  默认处理是终止进程
    ctrl+\   SIGQUIT  3  默认处理是终止进程
    kill -9  SIGKILL  9  默认处理也是终止,不允许被捕获 

   对于linux系统中的信号来说,其中 1 ~ 31之间的信号叫做不可靠信号，也就是不支持排队，可能丢失;其中34~64之间的信号叫做可靠信号，支持排队，不会丢失;而不可靠信号又叫做非实时信号,可靠信号叫做实时信号

2.2 信号的处理方式
(1)默认处理
(2)忽略处理
(3)自定义处理

2.3 信号的处理函数
  #include <signal.h>
  typedef void (*sighandler_t)(int) ;
  sighandler_t  signal(int  signum, sighandler_t handler);

解析：
   typedef void (*)(int) sighandler_t; 
   void (*)(int)  signal(int  signum, void (*)(int) handler);
=> void (*)(int)  signal(int  signum, void (*handler)  
    (int) );
=> void (*
      signal(int  signum, void (*handler) (int) )
   )(int)
=> void (*signal(int signum, void (*handler) (int) )
   )(int)
=> signal首先是一个函数名为signal的函数
   具有两个参数，第一个是int类型,第二个是函数指针类型
   返回值类型也是函数指针类型
=> 参数和返回值类型都是函数指针类型
   指向一个具有int类型参数,和void类型返回值的函数
如：
    int (*fn)(int,double); 
  => fn首先是一个指针
  => 指向两个参数类型分别int和double,返回值类型为int
     的函数  的指针

    int* fn(int,double);   
  => fn首先是一个函数
  => 两个参数的类型分别是：int 和 double,返回值类型是
    int* 的函数

函数功能解析：
   第一个参数：信号名称/信号值
   第二个参数：信号的处理方式
         SIG_DFL - 默认处理,绝大多数都是终止进程
         SIG_IGN - 忽略处理
         函数地址 - 按照指定的函数进行自定义处理
   返回值：失败返回SIG_ERR
   函数功能：表示对指定的信号设置指定的处理方式
 
练习：
   编程实现对信号2就行自定义处理,对信号3进行忽略处理，然后创建子进程打印子进程的PID，让子进程进入无限循环，父进程结束,然后对子进程发信号进行测试

2.4 父子进程对信号的处理方式
   (1)对于fork创建的子进程来说,完全照搬父进程对信号的处理方式,也就是说父进程自定义，子进程也自定义处理;父进程忽略，子进程也忽略处理;父进程默认，子进程也默认处理;
   (2)对于vfork创建的子进程来说，父进程忽略，子进程也忽略;父进程默认，子进程也默认处理;父进程自定义，子进程还是默认处理(主要原因在于execl函数跳转出去了)

2.5 信号的发送方式
(1)采用键盘发送方式(只能发送部分比较特殊的信号)
    ctrl+c  SIGINT  2
    ctrl+\  SIGQUIT 3
    ...
(2)程序出错的发送方式(只能发送部分比较特殊的信号)
    段错误    SIGSEGV  11
    总线错误  SIGBUS    7
    ...
(3)kill -信号值 进程号(可以发送所有信号)
(4)采用系统函数发送信号
   raise()/kill()/alarm()/sigqueue()

2.6 采用系统函数发送信号
(1)raise函数
   #include <signal.h>
   int raise(int sig);
函数功能：
   表示给调用进程/线程发送指定的信号sig,成功返回0,失败返回非0

    #include <unistd.h>
    unsigned int sleep(unsigned int seconds);
函数功能：
    表示让调用线程/进程进入睡眠状态,直到睡够了seconds秒或者被一个不能忽略的信号打断,此时睡眠被唤醒，如果睡够时间则返回0,否则返回还没有来得及睡的秒数

(2)kill函数
   #include <sys/types.h>
   #include <signal.h>
   int kill(pid_t pid, int sig);
第一个参数:进程号
    > 0 表示给进程号为pid的进程发送信号sig(掌握)
    0   表示给与当前进程同一个进程组的每个进程发信号
        (了解)
    -1  表示给当前进程拥有发送信号权限的每个进程发信
        号,进程1除外
        (了解)
   <-1  表示发送信号给进程组ID为PID的每一个进程(了解)
第二个参数:信号值
    0  表示不发送信号，而是检查指定进程/进程组是否存在
函数功能：表示向指定的进程发送指定的信号

(3)alarm函数
   #include <unistd.h>
   unsigned int alarm(unsigned int seconds);
函数功能：
   表示经过参数seconds指定的秒数之后发送SIGALRM信号,返回之前闹钟剩余的秒数，如果之前没有闹钟则返回0
   参数传递为0时，表示没有设置新的闹钟，取消闹钟
    
2.7 信号集的概念和使用
(1)信号集的概念
   信号集 - 信号的集合,linux系统表示信号1 ~ 64之间
思考：
   请考虑采用最节省内存的方式表示1~64之间的信号，用什么样的数据类型比较好?

如:  
   指针数组  int* arr[64];   256个字节
   数组      char arr[64];   64个字节
   采用每一个二进制位来表示是否由此信号即可  8个字节,采用unsigned long long int 类型
   0001 1011 表示当前信号集中拥有的信号:1 2 4 5
   
   信号集的数据类型：sigset_t 类型   128个字节
typedef struct
{
      unsigned long int __val[(1024/(8*sizeof(unsigned 
   long int)))];
} __sigset_t;
typedef __sigset_t sigset_t;

(2)信号集的基本操作
  #include <signal.h>
  sigemptyset() - 清空信号集,本质上就是将二进制置为0
  sigfillset() - 填满信号集,本质就是二进制置为1
  sigaddset() - 填充指定信号到信号集,也就是二进制置为1
  sigdelset() - 删除指定信号，也就是指定二进制置为0
  sigismember() - 判断信号集中是否存在某个信号,存在返回1,不存在返回0,出错返回-1

明日预报：
   (1)信号的处理 sigaction
   (2)进程间的通信





















   





   






   


