复习：
1.环境表的概念以及主函数原型
1.1 环境表的概念
   环境表 - 环境变量的集合
   本质上采用字符指针数组来存放所有的环境变量,也就是数组中每一个元素都是一个指针,用于存储每个环境变量的地址,
   char** environ;表示环境表的首地址,最后一个元素为NULL表示数组的结束

1.2 环境表的相关函数
   getenv() - 获取指定环境变量的值
   setenv() - 修改/增加环境变量到环境表中
   unsetenv() - 删除指定的环境变量
   putenv() - 修改/增加环境变量
   clearenv() - 清空环境表中   

1.3 主函数原型
   int main(int argc,char* argv[],char* envp[]){}
第一个参数：参数的个数
第二个参数：每个参数的首地址
第三个参数：环境表的首地址，environ

2.内存管理
2.1 程序和进程的概念
    程序：一般指存放在硬盘上的可执行文件
    进程：一般指运行在内存中的程序
2.2 进程中的内存区域划分
    代码区  只读常量区  全局区  BSS段 堆区 栈区
2.3 地址大小顺序
    地址从小到大排列：代码区  只读常量区  全局区  BSS段 堆区 栈区
    一般来说，堆区的地址从小到大申请，栈区的地址从大到小申请

2.4 字符串的存储形式比较
   对于指向常量字符串的指针来说，指向可改，内容不可改
   对于存储常量字符串的字符数组来说，指向不可改，内容可以改
   对于指向堆区的指针来说，指向和内容都可以改

2.5 虚拟内存管理技术
   unix/linux系统中，一般采用虚拟内存管理技术来管理内存的,每个进程都可以拥有0~4G的虚拟地址空间,操作系统自动进行虚拟地址和真实物理内存之间的映射
   其中0~3G地址叫做用户空间,3G~4G地址叫内核空间，内核会提供相关函数访问
   内存地址的基本单位是字节，映射的基本单位是内存页，目前主流的操作系统一个内存页是4Kb(4096字节)

2.6 段错误由来
(1)使用野指针和空指针
(2)访问一个没有经过映射的虚拟地址 
-------------------------------------------------------
今天内容：
   (1)内存管理
   (2)文件操作

1.内存管理
1.1 使用malloc申请动态内存
(1)使用malloc申请内存注意事项
    使用malloc申请内存时,除了分配指定的内存大小之外，还可能多分配12个字节的内存空间，用于存储管理内存的数据,内存空间的大小等信息,malloc底层采用链表形式存储
    使用malloc申请的内存空间时，不要进行越界访问 

(2)使用malloc申请内存的一般性原则
   使用malloc申请比较小的内存空间时，一般默认分配33个内存页
   #include <unistd.h>
   getpid() - 获取当前进程的进程号
   getchar() - 读取一个字符
   cat /proc/进程号/maps - 表示查看当前进程的内存分配情况,其中heap表示堆区,stack表示栈区

1.2 使用free函数进行内存的释放
    使用malloc申请比较小的内存空间时,系统一般默认分配33个内存页，如果malloc申请比较大的内存空间时，系统一般默认分配34个内存页,如果malloc申请的内存大于等于33/34个内存页时，系统会再次分配33个内存页，也就是按照33个内存页的整数倍进行递增
    使用free释放内存空间时，free释放多少则减去多少,不会按照33个内存页的整数倍释放,当free释放所有内存时，系统可能保留33个内存页备用，也就是free不保证立即释放内存，而是可以保证内存由使用状态变为非使用状态

1.3 内存相关的函数
(1)getpagesize函数
   - 获取当前系统的内存页大小
(2)sbrk函数
   #include <unistd.h>
   void *sbrk(intptr_t increment);
函数功能：
   表示申请参数指定大小的动态内存，成功返回操作内存之前的地址，失败返回-1,参数为0时表示获取当前内存的位置

注意：
   sbrk申请较小内存时,一般默认分配1个内存页的大小,而申请的内存超过一个内存页时，会再分配1个内存页，也就是按照1个内存页的整数倍进行处理的

(3)brk函数
   int brk(void *addr);  
函数功能：
   表示修改内存空间的末尾到参数指定的位置,也就是起始位置和目的地之间的范围都是有效内存空间

注意：
   sbrk函数和brk函数一般都是搭配使用,sbrk主要用于申请内存，brk函数主要用于释放内存

练习：
   使用sbrk和brk函数搭配使用,申请一个int类型大小的空间,存放整数100,再申请一个double类型的空间,存放3.14,再申请一个长度为10的字符串空间，存放数据"hello",打印以上内存中的数据，最后释放所有内存

(4)mmap函数
   #include <sys/mman.h>
   void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
第一个参数：给NULL即可，由内核指定
第二个参数：映射的大小，一般不足1个内存页会自动补齐
第三个参数：指定映射的操作权限
            PROT_EXEC - 可执行
            PROT_READ - 可读
            PROT_WRITE - 可写
第四个参数：指定映射是否对其他进程可见
            MAP_SHARED - 共享的
            MAP_PRIVATE - 私有的
            MAP_ANONYMOUS - 映射到物理内存
第五个参数：指定文件描述符
            映射物理内存时给0即可
第六个参数：文件中的偏移量
            映射物理内存时给0即可
返回值：成功返回映射的首地址,失败返回MAP_FAILED(-1)
函数功能：建立虚拟地址到物理内存/文件/设备的映射
       
(5)munmap函数
   int munmap(void *addr, size_t length);
函数功能：
   表示按照参数指定的地址和大小去解除对应的映射关系

如：
   0100
|  0010
|  0001
-----------
   0111 -> 7

小结：
   STL标准模板库
    => C++内存分配：new/delete 运算符
       => 标C函数：malloc()/free();
         => UC函数： sbrk()/brk();
           => 映射函数：mmap()/munmap();

2.系统调用
  系统调用是操作系统内核对外的一系列接口函数,当外部函数调用系统调用函数时，会通过软中断的方式把地址空间从用户空间切换到内核空间执行具体的功能，也就是操作内核，驱动硬件等操作,当系统调用函数执行完毕后，地址空间会自动从内核空间切换到用户空间

3.文件操作
3.1 文件概念
   在unix/linux系统中,几乎所有的一切都可以看做文件,所以对文件的操作适用于各种输入输出设备等
如：
   /dev/null - 表示空设备
   /dev/tty - 表示输入输出设备
   /dev/console - 表示控制台设备
   
   echo hello > /dev/null => 表示丢弃命令执行的结果
   cat /dev/null > a.txt  => 表示清空文件a.txt

3.2 文件基本操作
复习标C内容：
    fopen()/fclose()/fread()/fwrite()/fseek() 
(1)open函数
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   int open(const char *pathname, int flags);
   int open(const char *pathname, int flags, mode_t mode);
第一个参数：文件的路径和文件名
第二个参数：操作标志
      O_RDONLY - 只读
      O_WRONLY - 只写
      O_RDWR - 可读可写

      O_CREAT - 创建文件
      O_EXCL - 与O_CREAT搭配使用，表示不存在则创建，存
          在则创建失败
      O_TRUNC - 清空文件
      O_APPEND - 追加
第三个参数：操作模式
      在创建新文件时指定文件的创建权限，如：0666
返回值：
    成功返回一个新的文件描述符来标识此文件，失败返回-1
函数功能：打开/创建一个文件 

(2)close函数
   #include <unistd.h>
   int close(int fd);
函数功能：
    表示关闭参数指定的文件

(3)read函数
   #include <unistd.h>
   ssize_t read(int fd, void *buf, size_t count);
函数功能：
   表示尝试从fd指向的文件中读取count个字节的数据，存放到buf指定的缓冲区中,成功返回读取的字节数，失败返回-1

(4)write函数
   #include <unistd.h>
   ssize_t  write(int fd,const void *buf,size_t count);
函数功能：
   表示尝试着将buf指定的缓冲区中count个字节的数据写入到fd指向的文件中，成功返回写入字节数，失败返回-1

作业：
   查看lseek函数的使用
明日预报：
   文件操作
































