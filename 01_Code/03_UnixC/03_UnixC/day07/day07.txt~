复习：
1.文件的操作
1.1 fcntl函数的使用
(1)F_SETLK - 设置锁/释放锁

   文件锁不能锁定文件的读写操作,只能锁定其他的锁，也就是导致其他进程加锁失败(两个读锁除外)
   在读写操作之前尝试加锁，根据能否加锁成功，从而判断能否读写，一般来说，在读操作之前加读锁,在写操作之前加写锁

  释放锁的方式：
     a.进程结束自动释放所有锁
     b.将l_type = F_UNLCK,使用fcntl函数重新设置即可

(2)F_SETLKW - 功能与F_SETLK基本相同,加不上锁会等待
(3)F_GETLK - 测试锁能否加上
   如果参数锁能加到文件上,那么不去加，将参数锁的类型改为F_UNLCK，如果不能加锁,那么将文件上已经存在的锁信息通过参数锁带出来,其中l_pid变更为真正加锁的进程号

1.2 stat()/fstat()函数
   => 表示获取文件的详细信息
1.3 access()函数 
   => 判断文件是否有该权限 以及 文件是否存在
1.4 chmod()和truncate()函数
   => 设置文件的权限 和 修改文件的大小
1.5 umask()函数
   => 设置文件的创建时权限屏蔽字
1.6 mmap()/munmap()函数
   => 建立虚拟地址到文件的映射
1.7 其他函数
   link()/unlink()/rename()/remove()

2.目录操作
2.1 opendir()函数  => 打开目录  
2.2 readdir()函数  => 读取目录中的内容
2.3 其他函数
    getcwd()/mkdir()/rmdir()/chdir()/...
作业：
-------------------------------------------------------
今天内容：
   (1)进程和多进程的操作

1.进程和多进程的操作
1.1 进程的概念和基本命令
   程序：主要指存放在硬盘上的可执行文件
   进程：主要指运行在内存中的程序    

   ps - 查看当前终端中的进程
ps命令的执行结果：
   PID - 进程号
   TTY - 终端号
   TIME - 消耗CPU的时间
   CMD - 命令/进程的命令和选项  
      => whereis 命令 表示查看指定命令所在的位置

   ps -aux 表示显示所有包含其他使用者的进程
   ps -aux | more 表示分屏显示命令执行的结果
ps -aux命令的执行结果：
   USER - 用户名,也就是进程的属主
   PID  - 进程的进程号
   %CPU - 进程占用的CPU百分比
   %MEM - 进程占用的内存百分比
   STAT - 进程的状态信息
   TIME - 消耗CPU的时间
   COMMAND - 进程的名称
其中进程的状态信息主要有：
   S 休眠状态        s 进程的领导者
   Z 僵尸进程        R 正在运行的
   O 可运行状态      T 挂起状态
   < 优先级高的进程  N 优先级低的进程
   L 有些页被锁进内存

   ps -ef 表示以全格式的方式显示进程
   ps -ef | more 
ps -ef命令的执行结果:
   PPID - 父进程ID
   如果进程A启动了进程B，那么进程A叫做进程B的父进程，
而进程B叫做进程A的子进程
   一般来说，进程0是系统内部的进程，负责启动进程1和进程2,而其他的所有进程都是直接/间接地由进程1和进程2启动起来，而进程1也就是init进程
   
   kill -9 进程号 表示杀死指定的进程

1.2 各种ID的获取
   PID - 进程ID，系统采用PID唯一标识一个进程，在每一个时刻都可以保证PID的唯一性，采用延迟重用的策略
   #include <sys/types.h>
   #include <unistd.h>
   getpid() - 表示获取当前进程的进程号
   getppid() - 表示获取当前进程的父进程ID
   getuid() - 表示获取用户ID
   getgid() - 表示获取组ID   

1.3 进程的创建
(1)fork函数
   #include <unistd.h>
   pid_t fork(void);
函数功能：
   表示以复制当前运行进程的方式去创建一个新的子进程,如果成功父进程返回子进程的PID，子进程返回0,失败返回-1

(2)fork创建子进程之后，代码执行的方式是：
   a.fork函数之前的代码,父进程执行1次
   b.fork函数之后的代码,父子进程各自执行1次
   c.fork函数的返回值，由分子进程各自返回1次,也就是父进程返回子进程的PID,子进程返回0,可以通过返回值区分父子进程

注意：
   父子进程之间的执行顺序是不确定的,由操作系统决定

(3)父子进程之间的资源关系
   使用fork创建的子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享

(4)父子进程的关系
   a.父进程启动了子进程之后，父子进程同时执行,如果子进程先结束，会给父进程发信号,父进程负责帮助子进程回收子进程的资源
   b.如果父进程先结束,子进程会变成孤儿进程,子进程会变更父进程为init进程,也就是进程1,init进程叫做孤儿院
   c.如果子进程先结束，但是父进程由于各种原因没有收到子进程发来的信号,子进程变成僵尸进程

(5)扩展：
   a.如何创建4个进程？
     fork(); fork(); 调用两次
     1个父进程  2个子进程  1个孙子进程
   b.如何创建3个进程？也就是1个父进程 2个子进程
     fork();  1个父进程  和 1个子进程
     if(父进程)
     {
         fork();  1个父进程 又创建 1个子进程
     } 
   c.俗称：fork炸弹
     while(1)
     {
         fork(); //进程数采用指数级增长方式
     }

1.4 进程的终止
(1)正常终止
   a.在main函数中执行了return 0
   b.调用exit()函数  
   c.调用_exit()/_Exit()函数
   d.最后一个线程返回
   e.最后一个线程调用了pthread_exit()函数
(2)非正常终止
   a.采用信号终止进程
   b.最后一个线程被其他线程取消

(3)进程的终止函数
   #include <unistd.h>
   void _exit(int status); => UC函数
   #include <stdlib.h>
   void _Exit(int status); => 标C函数
函数功能：
   表示立即终止当前进程,参数为退出状态信息，用于返回给父进程,一般给0表示正常退出,给-1表示非正常退出

   #include <stdlib.h>
   void exit(int status); => 标C函数
函数功能：
   表示引起当前进程的终止,参数中的低八位被返回给父进程，终止进程的同时，会调用由atexit()和on_exit()函数注册过的函数

   #include <stdlib.h>
   int atexit(void (*function)(void));
函数功能：
   表示将参数指定的函数注册一下等待被调用

1.5 进程的等待
(1)wait函数
   #include <sys/types.h>
   #include <sys/wait.h>
   pid_t wait(int *status);
函数功能：
   表示挂起当前正在运行的进程，直到该进程的子进程状态发生改变，而子进程的终止也属于状态发生改变的一种,参数status用于获取子进程终止时的退出状态，成功返回终止的子进程pid，失败返回-1
   WIFEXITED(status) - 判断子进程是否正常终止
   WEXITSTATUS(status) - 获取子进程的退出状态信息
如：
   100 => 0110 0100
按位取反：1001 1011
再加1 :   1001 1100
转为十进制：
    128 + 16 + 8 + 4 = 156  

(2)waipid函数
   pid_t waitpid(pid_t pid, int *status, int options);
第一个参数：进程号
     <-1 表示等待进程组ID为pid绝对值的任何一个子进程(了解)
     -1  表示等待任意一个子进程(掌握)
     0   表示等待和调用进程同一个进程组的任何一个子进程(了解)     
    >0   表示等待进程号为PID的子进程(具体某一个，掌握)

第二个参数：获取退出状态信息
第三个参数：选项,一般给0即可
返回值：成功返回状态发生改变的子进程PID，失败返回-1
函数功能：
    表示按照指定的方式等待指定的子进程状态发生改变，并且采用第二个参数获取退出状态信息

注意：
    wait(&status) <=>  waitpid(-1,&status,0)

(3)工作方式
   a.调用wait()/waitpid()函数后,父进程开始等待子进程,而父进程自身进入阻塞状态
   b.如果没有子进程,父进程立即返回
   c.如果有子进程，但是没有已经结束的子进程，父进程保持阻塞状态，直到有一个符合要求的子进程结束为止
   d.如果有符合要求的子进程结束，那么父进程会获取子进程的退出状态信息并且返回

1.6 其他相关函数
(1)vfork函数
    #include <sys/types.h>
    #include <unistd.h>
    pid_t vfork(void);
函数功能：
    该函数功能与fork基本相似，所不同的是不会拷贝父进程的内存区域,而是直接占用父进程的存储空间,使得父进程进入阻塞状态，直到子进程结束为止,也就是说子进程先于父进程执行

(2)exec系列函数
   int execl(const char  *path,const char *arg, ...);
第一个参数：文件的路径
第二个参数：文件的执行方式/选项
第三个参数：可变长参数，选项
函数功能：
    表示根据参数的信息执行对应的文件
如：
   execl("/bin/ls","ls","-l",NULL);
  => 表示执行ls -l命令

注意：
    vfork函数本身没有太大意义，一般与exec系列函数搭配使用，可以实现多进程的并行;
    fork函数也可以与exec系列搭配使用，但是没有必要

(3)system函数
   #include <stdlib.h>
   int system(const char *command);
函数功能：
   表示执行参数指定的shell命令/文件

明日预报：
   (1)信号的概念和处理




















   



































 





































































