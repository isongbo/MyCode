复习：
1.静态库和共享库文件的概念和使用
1.1 基本概念和比较
(1)静态库
   使用方式是直接将代码/指令拷贝到目标文件中进行使用
优点：效率比较高,可以脱离静态库文件
缺点：目标文件占用空间比较大,不利于修改和维护

(2)共享库
   使用方式是将代码/指令的地址拷贝到目标文件中
优点：目标文件占用空间比较小,修改和维护比较方便
缺点：效率比较低,不可以脱离共享库文件

1.2 静态库的生成和使用步骤
(1)静态库的生成步骤
   a.编写源文件xxx.c (add.c)
   b.只编译不连接生成目标文件xxx.o
     cc -c add.c
   c.生成静态库文件
     ar -r lib库名.a 目标文件名
     ar -r libadd.a add.o
(2)静态库的调用步骤
   a.编写调用源文件xxx.c(main.c)
   b.只编译不连接生成目标文件xxx.o
      cc -c main.c
   c.链接静态库文件,主要有三种方式
     1)直接连接
       cc main.o libadd.a
     2)采用编译器选项
       cc main.o -l add -L .
     3)配置环境变量
       export LIBRARY_PATH=$LIBRARY_PATH:.
       cc main.o -l add

1.3 共享库的生成和使用步骤
(1)共享库的生成步骤
   a.编写源文件xxx.c (add.c)
   b.只编译不连接生成目标文件xxx.o
     cc -c -fpic add.c
   c.生成共享库文件
     cc -shared add.o -o libadd.so
(2)共享库的使用步骤
   a.编写调用文件xxx.c(main.c)
   b.只编译不连接生成目标文件 xxx.o
     cc -c main.c
   c.连接共享库文件
     1) cc main.o libadd.so
     2) cc main.o -l add -L .
     3) export LIBRARY_PATH=$LIBRARY_PATH:.
        cc main.o -l add
注意：
    必须配置 LD_LIBRARY_PATH 运行时加载问题

1.4 动态加载共享库文件
   #include <dlfcn.h>
   dlopen() - 打开和加载共享库文件
   dlerror() - 判断是否出错
   dlsym() - 获取具体的函数名所对应的地址
   dlclose() - 关闭共享库文件
   -ldl

2.C语言的错误处理
2.1 出错表示方式
   在C语言中，一般通过函数的返回值表示是否出错，一般性的原则是：
   (1)如果函数的返回值类型是指针类型，则返回NULL表错误
   (2)如果函数的返回值类型是int,并且函数的结果不可能是负数时，使用-1表示错误
   (3)如果函数的返回值类型是int，并且函数的结果可能是负数时，返回-1表示错误，而函数的执行结果通过指针作为形参带出
   (4)如果不考虑函数出错的情况，返回值类型使用void

2.2 错误编号
   函数的返回值可以表示错误,但是不能表示错误的原因，调用系统/标准库的函数时，一旦发生错误，修改errno的值
   #include <errno.h>

2.3 错误信息
   strerror() - 可以将参数指定的错误编号翻译成对应的错误信息，通过返回值返回
   perror() - 自动查找错误信息，进行打印，如果参数不为空,则原样输出，自动加换行(掌握)
   printf("%m") - 可以打印错误信息
-------------------------------------------------------
今天内容：
    (1)环境表和主函数原型
    (2)内存管理技术

1.环境表和主函数原型
1.1 环境表的概念
   环境表 - 表示各种环境变量的集合
如：
   PATH = ...:.          char* ps1;
   CPATH = ...:.         char* ps2;
   LIBRARY_PATH = ...:.  char* ps3;
   LD_LIBRARY_PATH = ... char* ps4;
   ...                   ...
C语言中表示字符串的形式如下：
   ""  常量字符串
   char str[20];  字符数组
   char* ps;      字符指针

   环境表：采用字符指针数组来存放所有的环境变量,提供全局变量char** environ来记录环境表的首地址,最后使用一个NULL表示数组的结束标志

1.2 相关的函数
(1)getenv函数
   #include <stdlib.h>
   char *getenv(const char *name);
函数功能：
   表示根据参数指定的环境变量名查找对应的环境变量值，查找成功通过返回值返回，查找失败返回NULL

(2)setenv函数
   #include <stdlib.h>
   int setenv(const char *name, const char *value, int overwrite);
第一个参数：环境变量名
第二个参数：环境变量值
第三个参数：是否修改， 0表示不修改，非0表示修改
返回值：成功返回0,失败返回-1
函数功能：修改/增加参数指定的环境变量到环境表中

(3)unsetenv函数
   int unsetenv(const char *name);
函数功能：
   表示从环境表中删除参数所指定的环境变量，如果不存在则函数调用依然成功，环境变内容不发生改变

(4)putenv函数
   int putenv(char *string);
函数功能：
   表示修改/增加参数指定的环境变量到环境表中，参数string的格式为:"name=value"

(5)clearenv函数
   int clearenv(void);
函数功能：
   表示清空环境表中所有的环境变量和对应的值，并且变量environ也置为NULL

1.3 主函数原型
   int main(int argc,char* argv[],char* envp[])
第一个参数：argc 参数的个数
第二个参数：argv 字符指针数组,存储每个参数的地址
第三个参数：envp 字符指针数组,表示环境表的首地址
   也就是相当于environ

如：
   cp a.txt b.txt => 采用命令实现的拷贝

编程实现：
    (1)打开文件a.txt和文件b.txt
       fopen("a.txt","r");
       fopen("b.txt","w");
    (2)读取a.txt中的内容写入到b.txt文件中
       fread()/fwrite()
    (3)关闭文件a.txt和b.txt
       fclose()

编写通用的文件拷贝程序：
    (1)打开源文件和目标文件
       fopen(argv[1],"r");
       fopen(argv[2],"w");
    (2)读取源文件中的内容写入到目标文件中
       fread()/fwrite()
    (3)关闭源文件和目标文件
       fclose()   
执行拷贝程序时：
    a.out a.txt b.txt => 实现从a.txt到b.txt的拷贝   
    a.out b.txt c.txt => 实现从b.txt到c.txt的拷贝
    a.out 源文件 目标文件 

作业：
    编程实现上述的通用文件拷贝程序

2.内存管理
2.1 程序和进程的概念
   程序：表示在硬盘上的可执行文件
   进程：表示运行在内存中的程序

2.2 进程中的内存区域划分
如：
   int num;  全局变量,默认初始化为0  BSS段
   int main(void)
   {
      int data; 局部变量,默认初始化随机数 栈区
      return 0;
   }

(1)代码区 
   - 主要存放代码的区域,也就是函数的地址等
(2)只读常量区 
   - 主要存放字符串常量和const修饰的全局变量
   - 该区域中的数据只允许读，不允许修改
(3)全局区 
   - 主要存放已初始化的全局变量和static修饰的局部变量
(4)BSS段
   - 主要存放未初始化的全局变量和static修饰的局部变量
   - 一般来说，会在main函数执行之前进行清零处理
(5)堆区
   - 主要指malloc/calloc/realloc函数申请的内存区域
   - 内存手动申请和手动释放
(6)栈区
   - 主要存放局部变量(包含函数的参数),const修饰的局部变量,以及块变量
   - 内存自动申请和释放

2.3 内存区域的比较
   内存地址从小到大依次排序为：代码区、只读常量区、全局区、BSS段、堆区、栈区
   其中对于堆区来说，一般分配的地址从小到大，而对于栈区来说，一般分配的地址从大到小，为了避免堆区和栈区产生重叠，而堆区和栈区没有明确的界限

2.4 不同形式字符串的比较
   对于指向常量字符串的字符指针来说，可以改变指针的指向，但是不可以改变指针指向的内容;
   对于指向常量字符串的字符数组来说，可以改变字符数组中的内容,但是不可改变数组名的指向;
   对于指向堆区内存的指针来说，既可以改变指针的指向，也可以改变指针指向的内容;

2.5 虚拟内存管理技术
   unix/linux系统中,一般都采用虚拟内存技术来管理内存,也就是：每个进程都有0~4G的虚拟地址空间(虚拟的，不是真实的内存)，由操作系统负责将虚拟地址和真实的物理内存映射起来，因此，不同进程中的虚拟地址可能相同，但是对应的物理内存不同
   其中0~3G的地址空间叫做用户空间，3G ~ 4G的地址空间叫做内核空间，用户程序一般都运行在用户空间,内存空间只有系统内核才可以访问,用户程序不能直接访问内核空间，但是内核提供了一些系统函数负责从用户空间切换到内核空间
   内存地址的基本单位就是字节,内存映射的基本单位是内存页;目前主流的操作系统中，一个内存页就是4Kb(4096字节)
   1byte(字节) = 8 bit(二进制位)
   1Kb = 1024byte
   1Mb = 1024Kb
   1Gb = 1024Mb
   1Tb = 1024Gb 
   
如：
    500万  酒店  10间房子   互联网时代  2间vip
携程网:    
    10000个房间号  网上预订
    路人甲：  
        8号  -> 8号房间  
             -> 10号房间
             -> 段错误

2.6 段错误的由来
(1)使用野指针/空指针可能引发的段错误
(2)使用了没有经过映射的虚拟地址

明日预报：
   (1)内存管理
   (2)文件操作   


   


















 








































   









   
