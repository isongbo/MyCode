回顾：
   实力永远第一位的。
   文件的一些函数： 
    dup() dup2() - 复制文件描述符，不复制文件表
    fcntl() - 复制文件描述符、获取/设置文件描述符的状态、文件锁
    stat() fstat() - 获取文件的属性(在硬盘上的 ls -il)
    access() - 判断文件是否存在 和判断当前用户的权限
    truncate() ftruncate() - 指定文件的大小
    remove() - 删除文件或者 空目录
    rename() - 文件、目录改名
    umask() chmod() ... - 不常用的
今天：
   目录的相关函数(递归、目录是树型结构)
   Unix/Linux进程管理 (多进程)
   目录的基本函数：
     mkdir() - 新建空目录(但有 . 和 .. 存在)   类似命令mkdir
     rmdir() - 删除 空目录(非空目录不能被删除)  类似命令rmdir
     chdir() - 更改当前目录   类似命令cd
     getcwd() - 获得当前目录的 绝对路径，返回字符串(pwd不打印)
  目录的读函数：
     读目录就是取目录的子项(子文件和子目录)，使用套路：
    1 opendir() 打开一个目录，返回 DIR*
    2 readdir() 读取一个子项，存入结构体并返回指针。循环读
    3 closedir() 关闭打开的目录(不关闭也问题不大)
   递归 - 函数自己调用自己
    递归的使用条件：
     1 要有退出条件，没有退出条件 栈会溢出。
     2 递归应该使问题简化，而不是更复杂。
     3 递归要考虑效率问题，如果效率低，避免使用递归。
   
  关于路径的分隔符：
    \ windows用的
   /  Unix/Linux用的，windows也兼容
   // 也不会报错，也能识别

  Unix的进程管理
    主流的操作系统都是多进程的，每个进程内部支持 多线程。Unix/Linux以 多进程为主。
    Unix的进程以 进程ID 作为唯一标识，同一时刻 PID不可能重复。
    查看进程的命令：
    ps  ： 只能显示当前终端启动的进程
    ps -aux : 能显示所有进程 (Linux可用，Unix不能直接使用)
    ps -ef : 能显示所有进程 (Unix、Linux通用)
    分页显示命令的结果：
    ps -aux | more  (| 叫管道， more 分页) 
     回车 、 空格  -  翻一行 翻一页
     q 退出

   操作系统在启动时，进程的启动是有次序的，如果在进程a中启动了进程b，a 就是 b的父进程，b就是 a的子进程。
   whereis 可以找到命令所在的目录

   Unix/Linux系统 先启动0进程，0进程 启动进程1(init)和进程2(有些系统只启动进程1)，其它进程都是 进程1 和进程2 启动的。
   进程的常见状态：
     S - 休眠状态，几乎所有的进程都是休眠状态
     R - 运行状态
     s  - 代表该进程有子进程(是父进程)
    Z  - 僵尸进程(已经结束但资源没有回收的进程)

   进程结束以后，它的PID能延迟重用(过一段时间以后可以重复使用)。查看进程ID的函数 getpid()，查看父进程的PID的函数 getppid()
返回的都是 进程的PID，类型pid_t，其实就是一个 非负整数。
    
   父进程启动子进程后，父子进程同时运行，如果子进程先结束，子进程会给父进程发信号，父进程负责回收子进程的资源。
   父进程启动子进程后，父子进程同时运行，如果父进程先结束，子进程变成 孤儿进程，会认 init进程(进程1)做新的父进程，资源交给init进程回收。init进程也叫 孤儿院。
   父进程启动子进程后，父子进程同时运行，如果子进程先结束，但没有来得及发信号或者父进程收到信号后没有处理，子进程变成僵尸进程。
   
   如何创建子进程？
    两种方法：
     1 fork() 函数通过复制自身去创建子进程，父子进程执行相同的代码区。
     2 vfork() + execl() 函数创建子进程，子进程将执行与父进程无关的代码。
   今天讲 fork() 。
    fork() 是一个非常复杂的简单函数。
     pid_t fork(void)
    没有参数，返回进程的PID，失败返回 -1 。
    
   fork() 创建的子进程会复制父进程的内存区域，代码区不复制，其它的区域(全局区、BSS段、堆、栈)都会复制。父子进程共享代码区。
   fork()之前的代码 只有父进程执行一次，fork()之后的代码 父子进程分别执行一次。
   fork()函数自身前半部分(创建子进程之前)会执行一次，后半部分(创建子进程之后)执行两次。fork()函数会有两个返回值，父进程会返回子进程的PID，子进程会返回 0 。
   创建子进程时，如果父进程的输入/输出缓冲区中有数据，子进程会复制父进程的缓冲区。
  创建子进程时，如果父进程有文件描述符，子进程会复制文件描述符，但不会复制文件表。这有可能导致父子进程读写文件冲突。
  fork() 创建子进程后，父子进程同时运行，谁先运行不确定，不同的操作系统有不同的算法，谁先结束更不确定。
  
  注： 子进程在复制父进程内存区域时，内存地址是一样的，但会映射不同的物理内存，把值拷贝过来。

  break 是用来退循环/switch的，return 是用来结束函数的，exit()是用来退出进程的。主函数中调用return也会结束进程。

 作业：
   1 掌握fork()
   2 写一个 类似 ls -l 命令的程序。
   操作文件时，会显示文件的详细信息(用户名显示用户ID即可stat())
   操作目录时，会显示目录的所有子项(readdir())




