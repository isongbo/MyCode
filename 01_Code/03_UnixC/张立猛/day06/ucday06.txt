回顾：
   文件描述符的概念 - 用文件描述符代表一个打开的文件，文件描述符本质就是一个整数，对应一张文件表。文件描述符从3开始，0 1 2 被系统占用。一张文件表可以对应多个文件描述符。
  读写函数 - open() read() write() close()
  lseek() 可以设置文件的偏移量
  
今天：
  文件的非 读写函数
  目录的函数 
   dup() dup2() - 复制文件描述符，但不会复制文件表
   dup()和dup2()的区别在于，dup()的目标描述符的值是系统选定，是 未使用的最小值；dup2()的目标描述符的值是程序员用第二个参数指定的，无论指定的描述符是否在使用，都会被目标描述符使用。 成功返回 目标描述符的值，失败返回 -1 。
   注: 如果dup2()指定的描述符已经被使用，将先关闭使用的描述符后继续复制。

  fcntl() 函数可以提供一些文件相关的功能，包括：
   复制文件描述符、获取/设置文件描述符的一些属性、文件锁
   int fcntl(int fd,int cmd, ...)
   参数fd就是文件描述符, ...代表0到n个任意参数
   cmd 决定了做什么，主要包括：
   F_DUPFD (long) - 复制文件描述符，如果传入的值已经被使用，不会强行关闭，而是使用 大于该值的 未使用的最小值；如果传入的值没有被使用，直接使用该值。 (了解即可)
  F_SETFL(long)/F_GETFL(void) - 设置/获取文件描述符的状态。
  能设置的只有O_APPEND，能获取的只有O_APPEND和权限。(了解即可)   
  F_SETLK / F_SETLKW / F_GETLK - 操作文件锁。
  返回值根据cmd的不同而不同。

  文件锁：
   有两个进程，分别往同一个文件中写数据，有可能引发数据的冲突。解决方案就是：把同时写(并行)改为一个写完另一个再写(串行)。实现的方法：可以从进程角度控制，从文件的角度控制。从文件的角度控制就是 文件锁。
   文件锁 用于控制多进程同时访问同一文件，文件锁对 读写文件都有控制。文件锁 采用的是读写锁，分为读锁和写锁，读锁就是允许其他进程读，但不允许其他进程写；写锁就是 其他进程不能读写。读锁是共享锁，写锁是独占锁。
    Linux系统提供了文件锁的全部机制，有一套成型的API。
    上锁函数用fcntl()，参数cmd用 F_SETLK/ F_SETLKW，区别就是F_SETLK是 非阻塞的方式，就是如果其他进程不能读写，直接返回-1；F_SETLKW是 阻塞的方式，就是如果其他进程不能读写，会等待，等到能读写为止。
   锁的属性由 第三个参数传入，是 结构体指针。
   struct flock{
     short l_type; //锁的类型
     short l_whence;//锁定的起始点参考位置
     off_t  l_start;//锁定起始点的偏移量
     off_t  l_len;//锁定的长度
     pid_t l_pid;//只有F_GETLK有效，SET时，置 -1 即可。
   };
   l_type包括： F_RDLCK - 上读锁  
                       F_WRLCK - 上写锁
                       F_UNLCK-释放之前的锁(fcntl函数可以上锁和解锁)
   l_whence包括：SEEK_SET/SEEK_END/SEEK_CUR，主要用SEEK_SET(从文件头开始)。
   l_start 是从参考位置的偏移量。和l_whence 一起决定了起始点。

  fcntl()上锁时，不会锁定读写函数(read()/write())，锁定的是其他进程的上锁函数(fcntl())。文件锁的正确用法是： 调用read()函数之前先加读锁，调用write()函数之前先加写锁，用完了记得释放锁。

  F_GETLK命令是测试一个锁能否加上，而不会真正的加锁，也不会获取锁，如果锁可以加上，就会把传入的锁的类型改为F_UNLCK，否则就把整个锁换成 当前正在执行的锁。(了解即可)

 stat() / fstat() 可以获取文件在硬盘上的各种属性，最常用的就是获取文件的大小(无需打开文件)。类似于 ls -il 效果。 
   
  程序员都是看手册(帮助文档 API)写代码。

  关于取某一位或某几位 二进制 可以使用 位与 运算。
   与0做位与 结果 为0 ，与 1位与 结果不变。
   number & 0000 1111 -> 取后4位
  八进制和十六进制 是二进制的简写，八进制 是 3合1 ，十六进制是 4合1。
  0000 1111 -> 八进制 017 -> 十六进制 0x0F
  八进制和7 位与不变，与0 位与清0 。
  十六进制 和 F 位与不变，与0 位与清0。
  比如，取后8位：
   & 0xFF

  access() 可以测试当前用户的权限和判断文件是否存在。
   int access(char* 文件名, int mode)
   mode 有4个值：
    R_OK   W_OK   X_OK - 判断是否有 读、写、执行的权限
    F_OK - 判断文件是否存在
   如果有权限或文件存在，返回 0 。

  其它的一些函数：
    chmod() / fchmod() - 修改文件的权限
    truncate() / ftruncate() - 指定文件的大小(占磁盘空间)
    remove() - 删除文件或 空目录(只有空目录才能被删除)
    rename() - 给文件或目录改名
    umask() - 改变 新建文件时，屏蔽的权限。

  mmap() 映射硬盘文件
   
   




