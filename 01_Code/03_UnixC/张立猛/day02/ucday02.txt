回顾：
   Linux、Unix的历史渊源
   gcc编译器常用的选项
   -E  -S -c -o 
   -c -o 是必须会的
   -Wall
   头文件和源文件
    所有的声明都在头文件中，包括：变量声明、函数原型、结构、联合；所有的实现都写在源文件中，包括：变量的赋值、函数的代码。
   指令，以#开头的叫指令
    最常用的指令：#include #define #if #elif #else #endif #ifndef #ifdef 
    特殊用法： #warning #error  #pragma 
今天：
   环境变量
   静态库和共享库(动态库)
   C程序员的错误处理
   环境表和相关函数(从程序员的角度处理环境变量)
   
   操作系统由内核和Shell组成，内核完成的核心的功能。Shell是内核和用户之间的接口(桥梁)，Unix系统常见的Shell包括：
   sh - 最早的Shell
   bash - sh的增强版，多了很多额外的支持，现在主流shell
   csh - 按照C程序员的习惯写的shell
   
   敲ps后回车， 可以看到bash的进程
   敲sh后回车
   敲ps后回车， 可以看到sh的进程
   退出shell时，用exit命令
  远程登录命令：
    telnet 192.168.0.23 
    用户名和密码是 openlab   open123

  sh和bash中，普通用户命令提示符是$; csh中，普通用户的命令提示符是%; 对于root用户，命令提示符是 #。

   操作系统中，有很多的辅助数据需要存在内存中，其中有一部分就是环境变量。比如：PATH就是系统路径的辅助数据，一般来说，可执行文件要带上路径才能执行；而定义在PATH中的路径系统自动能找到，因此可以省略路径。对于C程序员来说，环境变量包括：
   CPATH - 用来定位头文件的环境变量
   LIBRARY_PATH - 用于连接时定位库文件
   LD_LIBRARY_PATH - 用于运行期间定位共享库文件
 
  配置环境变量时，要保证以前的不变，然后再加入新的。
   $PATH 代表环境变量PATH的值
   echo $PATH -  打印输出PATH的值
  目前讲的配置环境变量的方式是bash下的，csh下是不同的。  
   export PATH=.:$PATH
    . 代表当前目录   : 是路径的分隔符  $PATH代表以前的值
  在命令行敲 export PATH=.:$PATH 只对当前窗口有效，如果想持久有效，需要 把命令写到 启动文件中。bash中，启动文件可以选登录目录(~)下 .bashrc (还有其他的启动文件)，把export PATH=.:$PATH 写入 .bashrc 就持久有效了。

  Unix/Linux的库文件
    大型项目中，如果每个函数都在不同的.o文件中，项目管理是灾难，库文件可以解决问题。把相关的.o文件打包到库文件中，代码从库文件中获取。商业开发中，每个程序员都是提供一个或几个 头文件+库文件。
   库文件有两种，静态库和共享库(动态库)。静态库是代码的合集，使用方法是 直接复制代码到目标文件中；共享库是代码的合集，使用方法是 复制代码在共享库中的地址 到目标文件中。
   静态库的优点 速度稍快，在运行时不需要库文件(独立性)，缺点是占用空间大，不利于修改和维护。共享库的优点 占用空间小，修改和维护方便；缺点 速度稍慢，在运行时需要库文件同时存在。
   商业开发中，以 共享库为主流。
   创建和使用库的步骤
    静态库(后缀是.a文件)
    创建静态库的步骤。
     1 写源程序，保存退出。
     2 用gcc -c 编译，生成 .o文件。 gcc -c add.c
     3 ar -r 命令创建静态库文件
        ar -r libmyku.a add.o
     静态库文件名有规范，前面必须是lib开头，后缀必须是.a，中间写上 库名。库名和库文件名是不一样的，库名不带前缀和后缀。
    调用静态库的步骤：
     1 写源程序，保存退出。
     2 用gcc -c 编译，生成 .o文件。 gcc -c test.c 
     3 连接静态库文件和test.o，方式有三种：
       a 直接连接法  gcc test.o libmyku.a
       b 双L连接法  gcc test.o -l库名 -L库路径
       c 单L连接法  先配置环境变量LIBRARY_PATH，把库路径写入，用 gcc test.o -l库名 即可。

   共享库(.so)的创建和使用
    创建步骤：
     1 写源程序，保存退出。
     2 用gcc -c 编译，生成 .o文件。 gcc -c -fpic add.c
     3 gcc 命令创建共享库文件
        gcc -shared add.o -olibmyku.so
     调用的步骤和方法与静态库完全相同。
     注意： 共享库在运行时，必须先配置环境变量LD_LIBRARY_PATH。
   
    命令ldd 可以显示所有相关的共享库以及它们的地址。
     ldd a.out
    系统提供了一些直接操作共享库的函数，包括：(了解)
     dlopen()  -  打开一个共享库
     dlsym() - 从一个打开的共享库中 打开一个函数，返回函数指针
     dlclose() - 关闭打开的共享库文件。
     dlerror() - 判断是否出错。
  
   C程序员的错误处理
     程序员 都要写错误处理的代码，错误处理是软件的一个组成部分。后期的语言都是使用 异常机制(Exception)处理错误，而C语言没有使用异常机制。
     C程序员用 函数的返回值代表是否出错，错误处理的代码需要单独编写。
     错误处理的方式有四种：
     1 如果函数的返回值是int，并且返回的数据不可能是负数，可以用返回 -1 代表出错，其它正常。
     2 如果函数的返回值是int，并且返回的数据可能是负数，用返回-1代表出错，用返回0 代表正确；数据用传入指针带回来。
     3 如果函数的返回值是指针，返回NULL代表出错。
     4 如果函数不可能出错或不需要考虑出错的情况，返回数据正常返回即可。一般用 void 代表 不考虑出错，数据可以用返回值或指针返回。
    注：以上四种情况只是C程序员的常规处理方案，可以不按这个方案进行错误处理。

    练习： 写4个函数，针对上面四种错误处理的情况。主函数做测试
    
    1 比较两个数的大小并返回最大值，如果相等，返回错误。(第二)
    2 返回0-9的随机数，如果随机到0，返回错误。(第一)
    3 换行打印传入的字符串。(第四)
    4 判断传入的字符串，如果是"error"，返回错误，否则返回原来的字符串。 (第三)

   C语言提供了出错处理的相关函数和变量，一个变量+3个函数：
    外部全局变量 errno 记录错误的编号
    strerror()      - 把错误编号转换成错误信息
    perror()        - 打印errno对应的错误信息
    printf("%m")- 打印errno对应的错误信息
   调用系统函数时，如果发生了错误，系统会把错误的编号记录在errno中，如果不发生错误，什么都不做。
   注: errno是出错会改变值，不出错不会还原 原来的值。因此不能用errno判断是否出错。
   经验：
    C语言中，返回值可以代表是否出错，出了什么错，errno会记录
    不是所有的函数都使用了errno，有些函数(比如线程相关函数)没有使用errno。

  环境变量和环境表
    程序中，所有的环境变量都存在一个 字符指针数组(char* arr[])中，用 extern char** environ; 就可以直接获得存储所有环境变量的字符指针数组的首地址，而这个字符指针数组就是 环境表。NULL代表环境表的结束。

    二级指针和字符指针数组的关系，是可以互相代表的。
    指针和数组的关系？
    数组 其实就是一个常指针(不能改变地址的指针)，在大多数情况下，和指针可以互相混用。不同的地方：
    1 sizeof() 指针 在32位 系统中 恒定是 4 字节。
       sizeof() 数组 是 数组的长度*sizeof(元素)，是数组的真实大小。
    2 返回值类型 可以写 指针，但不可以写数组。
   一级指针可以看成一维数组，二级指针可以看成二维数组。

   指针的算数运算(加减)
    int* p;
    (p+1) 移动了4个字节  sizeof(int) 
    char* p;
    (p+1) 移动了1个字节  sizeof(char)
   指针的加1 移动的字节数由 sizeof(指向的类型) 决定。
    char** p;
    (p+1) 移动4个字节 sizeof(char*)

    QQ: 1093 0091


