回顾：
   内存分配的6个函数 - malloc() free() sbrk() brk() 
     mmap() munmap()
   文件读写函数 - open() read() write() close()
   
今天：
   文件描述符 - 文件描述符的原理
   读写函数(以练为主)
   文件的非读写函数

   文件 - 操作系统都有文件系统常见的文件系统：fat32、ntfs等。
    Linux系统中，几乎一切都可以看成文件。目录、内存、各种硬件设备都可以看成文件，采用操作文件的方式(命令/函数)也可以操作目录、内存和硬件设备。
    /dev 是设备目录，各种输入输出设备都可以对应该目录下的某个文件 或 文件夹(目录)。 比如：
   /dev/tty 代表键盘和显示器
    echo hello > /dev/tty
    cat < /dev/tty 
   可以查看一下效果
   /dev/null 代表空
    echo hello > /dev/null 
    清空文件的内容： cat  /dev/null > a.txt

  类似于 内存地址管理内存，文件 是用 i节点 进行管理的，i节点可以认为是 文件/目录 在硬盘上的 地址。
  ls -i 可以查看i节点。

  open() read() write() close() ioctl() 可以操作很多的设备，像操作文件一样。
  文件描述符的本质就是一个整数，可以代表一个打开的文件。但文件的信息不是存在文件描述符中，存在 文件表 中。open()函数在打开文件时，会把文件的信息放入文件表中，但出于安全和效率考虑，文件表不适合直接操作，可以给文件表做一个编号，拿编号进行操作，这个编号就是 文件描述符。
   系统会管理文件描述符，每个进程都有一张描述符总表，当有新的描述符需求时，会去总表中查找未使用的最小值并返回。文件描述符是非负整数，从0开始，到OPEN_MAX(Linux一般是255)，其中0 1 2 被系统占用，代表 标准输入、标准输出和标准错误。
   open()工作方式是： 把文件信息存入文件表中，然后去文件描述符总表中查找未使用的最小值做文件描述符，再把对应关系放入总表中。
  close()的工作方式：先把对应关系从总表中移除，不一定会删除文件表，只有当文件表没有其他描述符与之对应时(一张文件表可以对应多个描述符)，才会删除文件表。close()不会改变文件描述符的整数值，但会让文件描述符无法代表一个文件。

  读写文件的函数 - open() / read() /write() /close()
   练习：
    写一个员工管理系统的模块，登录和新增模块。
     1 把员工信息写入文件中。 (追加写)
     2 把员工信息从文件中读出来。(循环读所有)
    注：员工应该写一个结构体，放入头文件中，包括信息：编号、姓名、工资。
   要求使用UC的4个函数，员工信息用scanf()输入。


 练习：
   只有文本型(char*/char[])的数据才能被正常显示。改变上面写文件的代码，改成 全部数据都可以被正常显示。
   提示：把结构的数据存入字符串中
  
  读写文件现在有两种方式： 标C函数和UC函数，那么哪个更合适呢？
  在Unix/Linux系统中，标C函数的底层使用了UC函数。

  time a.out 可以测试a.out的执行时间，包括：用户时间和内核时间，总时间。

 标C的输入输出函数都是有输入/输出缓冲区，也就是说，数据先存入缓冲区，等缓冲区满了再写入文件。UC函数在应用层没有缓冲区，如果频繁输入输出，程序员要自定义缓冲区。

   函数lseek() 可以设置文件当前偏移量，文件偏移量就是文件的读写的位置。刚刚打开的文件，偏移量在0，文件开头；用O_APPEND方式打开的文件，偏移量在文件尾。文件偏移量记录在文件表中。函数： read() write() lseek() 等可以改变偏移量。读写函数都会在读写之后将偏移量后移一位。

  标C中，取文件的大小要用 fseek()到文件尾，然后调用ftell()得到
  UC中，直接掉lseek()到文件尾，返回的就是文件的大小。
  off_t  lseek(int fd,off_t offset,int whence)
   参数 fd 就是文件描述符   offset就是偏移量  whence就是偏移量的起始位置，包括：SEEK_SET(头)/SEEK_CUR(当前)/SEEK_END(尾)。
  返回，成功返回当前位置和文件头的差，失败返回-1。

  作业：
   编写以下用户注册和用户登录，用户写成一个结构，包括：
   用户名、密码和email。密码要求确认，如果输入的不同，需要循环输入。
   第一个版本可以不考虑用户名重复的问题。
   第二个版本要求用户名不重复。








