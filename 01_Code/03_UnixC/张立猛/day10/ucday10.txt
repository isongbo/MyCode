回顾：
   信号signal - 程序员如何自定义信号处理方式
    signal()/sigaction()
    程序员写上处理函数 - 核心
    信号集 - sigset_t ，可以看成一个超大整数，可以存放所有信号的有无。信号集有5个运算结构(函数)：sigaddset() sigdelset() sigfillset() sigemptyset() sigismember()
    信号屏蔽 - 在执行关键代码时，不希望信号打断代码。信号屏蔽不是 屏蔽信号的到来，但是 可以暂时不对信号做处理。信号屏蔽有可能造成 不可靠信号的丢失，但 未必会影响程序的效果。不是所有的信号都可以屏蔽的，信号9 就屏蔽不了。
   IPC进程间通信 - 常见的IPC方式包括： 文件、信号、管道、共享内存、消息队列、信号量集、网络编程(socket)
   IPC都需要一个交互的媒介，一般是 内存或文件。
今天：
   管道的代码
   XSI IPC - 共享内存、消息队列和信号量集遵循相同的规范，得名XSI IPC。
   共享内存和消息队列(重点) - IPC主流
   XSI IPC的共性：(设计的理念非常类似)
    1 共享内存、消息队列和信号量集的实体 统称为IPC结构，IPC结构是由 内核管理。
    2 每个IPC结构都有一个外部的key和一个内部的ID，外部的key用于获取/创建 内部ID，内部ID 代表IPC结构。
   3 每个IPC结构如果不手工删除的话，重启机器 不会被删除。创建IPC结构的时候要考虑进程结束时 删除IPC结构。
   4 外部key类型是key_t，有三种方式可以获得(明3实2)：
    a 使用宏IPC_PRIVATE，但这种方式只有本进程能获取，其它进程拿不到。(基本不用)
    b 函数 ftok()，可以使用真实存在的路径+项目ID 生成一个key。
    c 可以定义头文件，把 项目中所有的key 定义到一个公共的头文件中。key 其实就是一个整数。
   5 函数 xxxget() 可以用key 创建/获取 内部ID，比如：shmget() msgget()，创建时 flag使用宏 IPC_CREAT|0666，获取给0即可。
   6 还提供了一个叫xxxctl()函数，可以对IPC结构进行 删除、修改和查询，比如：shmctl() msgctl()，支持3个宏：
    IPC_STAT - 查询
    IPC_SET - 修改
    IPC_RMID - 按ID删除
   7 可以用命令查看或删除 IPC结构：
    ipcs - 查看
      ipcs -a 看所有
      ipcs -m 查看共享内存  
      ipcs -q 查看消息队列
      ipcs -s 查看信号量集
    ipcrm - 按内部ID删除

  共享内存：
   共享内存 以一块内存作为交互的媒介，操作系统内核会管理一块物理内存，这块物理内存 允许所有进程映射(挂接共享内存)，挂接成功后数据可以直接存入物理内存，其它进程也挂接到这块内存上，就直接完成了IPC。共享内存是 速度最快 的IPC方式。
   共享内存的编程步骤：
    1 使用 ftok() 或头文件 获得外部的key。
    2 使用 shmget(key,...)创建/获取 内部ID，即 物理内存搞定。
    3 使用shmat(内部ID,...) 挂接(映射)物理内存。
    4 把数据存入共享内存/从共享内存中取出(用法和普通内存一样)。
    5 使用shmdt() 脱接物理内存(解除映射)。
    6 如果确定不再使用共享内存，可以使用函数shmctl(IPC_RMID)删除。

  注： 常用的属性中，只有权限能改。因此 修改的意义不大。
    删除共享内存时，只是做了一个删除标志，不保证当时删除；只有没有进程挂接的共享内存才能被删除。

   共享内存的优点 就是速度最快，缺点就是面对多进程同时读写操作时，比较麻烦。解决方案 就是消息队列。

   消息队列 - 就是把数据封入消息中，再把消息放入队列中。数据的存放和取出都从消息队列中实现。
   消息队列的编程步骤：
    1 使用ftok()获取key。
    2 使用msgget() 创建/获取一个消息队列。
    3 使用 msgsnd() / msgrcv() 发送或接收消息。(消息队列)
    4 如果不再使用消息队列，用msgctl(IPC_RMID)删除。
  注：消息队列的删除 会无视 消息队列是否为空，需要程序员自己控制。

   消息队列的完整用法：
    消息分为有类型消息和无类型消息，有类型消息都是结构体，
  struct 结构名{ //程序员可以随便起名
    long mtype; //第一个成员必须是long，消息的类型
    ....//数据区，可以是 char[] ，也可以是结构，数量可以有多个
   };
   无类型消息就是任意类型都可以。应用中 有类型消息是主流。
   当发送方使用有类型消息时，接收方可以按照消息类型选择消息。
   有类型消息：
   int msgsnd(int msgid,void* msg,size_t size,int flag)
   msg 是消息结构的首地址，size是数据区的大小(不带mtype)。
   flag 一般0 或者IPC_NOWAIT， 0 代表阻塞，IPC_NOWAIT就是如果消息队列满了，不会等待而是直接返回错误。
   返回值，成功返回0，失败返回 -1 。

  int msgrcv(int msgid,void* msg,size_t size,long mtype,
   int flag)
   参数 msg 是用于接收数据的消息结构的首地址，size 是 数据区的大小，mtype是接收消息的类型，可以是正数、0和负数。flag和msgsnd一样。
   当mtype是正数时，只接收该类型的 消息。
                 是零时，接收所有类型的消息(先入先出)。
                 是负数时，接收类型小于等于mtype绝对值的消息，接收的次序是从小到大。
   
 明天的综合案例需要用到的知识点：(程序员的一天)
  文件读写、stat()、access()、remove()
  进程管理，启动多进程
  信号 3 步
  消息队列






