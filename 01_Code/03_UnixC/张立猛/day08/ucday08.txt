回顾：
   目录的相关操作 - mkdir() rmdir() chdir() getcwd() 
    opendir() readdir() closedir()
   进程管理  - 操作系统启动程序，就形成了进程。进程由PID唯一标识，PID是一个 非负整数，由系统分配和管理，延迟重用。
   进程创建有两种方式：
    fork()  -  通过复制父进程创建子进程
    vfork() + execl() - 创建全新的子进程，不复制
    fork()复制除了代码区之外的所有内存区域，包括：堆、栈、全局、BSS段、缓冲区、文件描述符等。但复制文件描述符时，不会复制文件表。fork()创建子进程后，父子进程同时运行，但无法确保谁先运行，谁先结束。
今天：
   进程的终止(结束)
   wait()和waitpid() - 让父进程等待子进程的结束
   vfork() + execl() - 创建子进程的第二种方法
   信号   
   进程的结束：
    正常结束 - 
      主函数执行return语句
      执行了 exit() 函数(无论在哪里)
      执行了_Exit() 函数 或 _exit() 函数
      最后一个线程退出
    非正常结束 - 
      被信号结束
      最后一个线程被取消

  exit()、_exit()和_Exit()
   _exit()和_Exit() 底层的实现是一样的，区别在于_Exit()是标C函数，_exit()是UC函数。
   exit()和_Exit()的区别
    _Exit() 会 立即退出进程，而不会做太多的工作；exit()不是立即退出进程，可以先执行 atexit()注册的函数后 再退出进程。两个函数都可以用参数给 父进程传值。
   exit()的参数只要是整数就可以(但只有低8位有效)，父进程会取得这个参数，用于判断 子进程是否完成了任务(通常情况下，用负数代表没有完成任务)。

  wait()和waitpid()
   wait()和waitpid()能让父进程等待子进程的结束，在子进程结束之前，父进程处于阻塞状态，并且取得子进程的退出方式和退出码(exit()括号中的值或者return后面的值)。
   wait()和waitpid()的区别在于，wait()等待方式比较单一，而waitpid()非常灵活；wait()只能等待任意一个子进程结束，父进程一定会阻塞，而waitpid()可以指定等待 一个或多个子进程，可以选择阻塞或 不阻塞。
   pid_t wait(int* status)
    参数status可以带出 子进程的退出方式和退出码，返回结束子进程的PID，如果没有子进程结束，父进程将 阻塞，等待子进程的结束。如果有僵尸子进程，wait()也可以回收，因此 wait()也被称为：敛尸工。
   宏函数 WIFEXITED(status)可以判断子进程是否正常退出，
              WEXITSTATUS(status)可以取得退出码。

   pid_t waitpid(pid_t pid,int* status,int options)
   参数pid可以指定等待某个或某些子进程，其值可能是；
     < -1  等待进程组ID = pid绝对值的子进程
      -1    等待任意一个子进程
      0     等待和父进程一个进程组的子进程
     > 0   等待进程ID = pid的子进程(等待特定的一个)
     status的用法和wait()一样。
     options 可以为0 ，代表阻塞；或WNOHANG 代表非阻塞。
   返回： 
     正数  - 就是等到结束的子进程的PID
      0     - 就是没有子进程结束，但options为WNOHANG 非阻塞
      -1    - 出错
   注: pid的值一般都是 -1 或 大于0 ，另外两种情况 较少使用。

   vfork() + execl() 
    vfork() 在语法上与fork()完全一样，但机制和fork()完全不同。
     vfork()不会复制父进程的任何的资源，先抢占父进程的资源运行，父进程会被阻塞，这种阻塞的解除有两种方式：1 子进程结束，资源还给父进程。 2 子进程调用exec系列函数(比如：execl())，有了新的资源，原先抢占的资源会还给父进程。
    第一种方式没有实际的意义，因为父子进程不会并行(同时运行)。
   vfork()从原理上 确保子进程先运行。
   注： 用vfork()创建的子进程必须用 exit()函数显式 退出，否则可能引发错误或死循环。

   execl()是exec系统函数中的一个，功能是 用一个新的程序替换掉当前进程，当前进程的PID不变，但所有的内存区域会发生改变，换成新的程序的内存区域。execl()函数不会新建进程，但会 替换到进程的代码和数据。
   
   int execl(char* filename,char* cmd,char* arg,...)
   参数 filename 就是 启动程序的文件名（带路径）
    cmd 就是启动程序时，敲的命令
    arg 就是命令的选项
    ...  可以跟命令的参数
   其中 filename必须有并且正确， cmd 必须有(即使写错也能启动)
   选项和参数可以有也可以没有，最后一个参数写NULL代表结束。
  成功就会换掉程序，所以 没有返回，失败返回 -1 。

   比如想 调用系统的ls 命令，执行命令是： ls -l 
     execl("/bin/ls","ls","-l",NULL);

   练习：
    用execl()+vfork() 的方式测试一下 excel()不会改变进程PID。
    写两个.c文件，其中一个vfork()+execl()，在执行execl()之前打印一下子进程PID，execl()函数启动另外一个程序(另外一个.c连接成b.out)，在b.out打印出进程pid。

 信号(signal)
   信号是Unix/Linux系统中 最常见的一种 软件中断 方式。中断就是中止当前的代码，转而执行其他代码。中断分为 硬件中断和软件中断。
   信号本质 就是一个 非负整数，每个信号都有一个宏名称，以SIG开头，比如：信号2 的名称就叫 SIGINT。信号在Unix系统和Linux系统中是不同的，有些信号的值都不同，但宏名称是一样的，所以编程时用宏名称代表信号有更好的兼容性。Unix的信号0-48，中间不保证连续；Linux的信号0-64，中间也不保证连续。信号0 有特殊用途，没有赋予 0 实际的意义。信号0 可以用于测试权限。
  信号分为两类，可靠信号和不可靠信号。Linux系统中，不可靠信号1-31，特点是不支持排队，因此当多个相同信号同时到来时，可能会丢失。可靠信号34-64，特点是支持排队，可靠信号不会丢失。
  常见信号：
   SIGINT     Ctrl+C     信号2     效果是退出进程
   SIGQUIT   Ctrl+\     信号3     效果是退出进程并存入core文件
   ...
   段错误、总线错误、整数被0除 等都是信号。
 
 想看系统都有哪些信号，用kill命令。kill命令是给进程发信号的。
  kill -l 可以查看有哪些信号。
  kill -信号 进程PID - 可以发送信号给某进程

 信号的处理方式：
  1 默认处理，系统默认对信号有一套处理方法。大多数的默认处理都会退出进程。
  2 忽略信号，系统可以当信号从来没有发生过。
  3 程序员自定义信号处理函数，当信号到来时执行程序员自定义的处理函数代码。
  注：
   不是所有的信号都可以忽略或自定义，信号9就只能执行默认处理
   不是所有的进程都可以发信号，普通用户只能给自己的进程发信号，root 用户可以给所有进程发信号。

  信号的处理方式可以用signal() 或 sigaction() 进行设置和改变，signal()比较简单，可以应对大多数的场景。主讲signal()。
   信号的90%应用都使用signal()。

   void (*fa)(int)  signal(int signum,函数指针)
    参数 signum 就是要设置处理方式的信号的值，
        函数指针就是信号的处理函数 或忽略 或默认，其中处理函数是程序员自定义的，格式： void fa(int signo){ ... ;}，调用signal()函数时传入函数名即可。忽略信号，第二个参数给SIG_IGN；默认处理，第二个参数给SIG_DFL。
     返回值，成功返回之前的处理方式，一般用不到，失败返回 SIG_ERR。
   信号的编程步骤：
    1 #include <signal.h> 包含头文件
    2 写处理函数，格式： 
     void fa(int signo){ ...;  }
    3 在主函数中，调用 signal()函数把信号和处理函数关联起来。

  练习：掌握信号编程的3个步骤
   写一个新的程序 signal2.c，当有信号14到来时，打印 变型金刚4很好看。 
    




