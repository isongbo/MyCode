回顾：
   静态库和共享库 (创建和调用)
   环境变量和环境表 - 环境表就是存储环境变量的字符指针的数组，对于环境变量的操作可以使用环境表。 extern char** environ; 环境表以NULL作为结束。
   C程序员的错误处理 - 用返回值代表是否出错，出了错以后 使用perror() + errno 进行错误的判断和显示。
   关于返回值如何代表出错，有4种情况：
   1 如果返回是int，并且返回的数据不可能是负数，用 -1 代表出错，数据正常返回。
   2 如果返回是int，但返回的数据可能是负数，用-1代表出错，用0代表正常，数据用指针带回来。
   3 如果返回是指针，用NULL代表出错，其它正常。(有些函数用-1代表出错)
   4 如果不需要考虑是否出错，返回值void 或 正常返回。

今天：
   环境变量和环境表相关的系统函数
   Unix/Linux系统的内存管理 - 相关函数、进程的内存划分、虚拟内存机制(Unix内存管理的方式)
   系统对环境变量的操作提供了一些函数：
   getenv() - 按 环境变量的名取环境变量的值
   putenv() - 设置环境变量(新建或修改已存在环境变量的值)
   setenv() - 设置环境变量(新建或修改已存在的值或不修改值)
   unsetenv() - 按 环境变量的名 删除
   clearenv() - 全部删除 环境表中的环境变量

  Unix/Linux系统的内存管理
   相关函数
   STL     ->  内存自动管理(自动分配、自动回收)
     |
   C++    ->  new 分配，delete 回收
     |
    C        ->  malloc()分配，free()回收
     |
 Linux系统函数   ->  sbrk() 和 brk()
    |
 Linux系统函数   ->  mmap()和munmap()
    |                                                      (用户层)
――――――――――――――――――――――――――
    |                                                      (内核层)
 Linux系统函数  -> kmalloc()/vmalloc()

 现阶段研究用户层即可，从C开始到mmap()，6个函数。

 进程的内存空间
   程序和进程的概念
    程序是代码编译连接以后的产物，是硬盘上的文件。
    进程是运行起来的程序，是内存中运行的程序。
   严格来说，内存空间是针对进程而言的，程序没有内存空间。但进程专业性太强，所以很多时候用程序 代表进程。
  一个进程主要包括以下内存空间：
   1 代码区 - 用于存储代码，函数指针就是指向代码区。是只读区。
   2 全局区 - 用于存储全局变量，static修饰的局部变量也在全局区，全局区在main()函数运行之前就创建，程序结束前才销毁。
   3 BSS段 - 存储 未初始化的全局变量，BSS段和全局区的唯一区别在于：在main()函数运行之前，BSS段会 自动清0。
   4 栈区(堆栈区 stack) - 存储局部变量(非static的)，包括：函数的形参，局部变量和块变量。栈区 系统自动管理。
   5 堆区(heap) - 也叫自由区，程序员唯一能管理的区域。堆区系统不会主动管理。堆区的内存分配和回收都 由程序员完成，系统不会做任何的管理。堆区如果只分配，不回收就会造成内存泄露。
   6 只读常量区 - 很多的书上都是把这个区域并入代码区。字符串的字面值(" "括起来的)和 const 修饰的全局变量 在只读常量区，只读区域。修改只读区 会引发 段错误。

  虚拟内存机制 - Unix/Linux 的虚拟内存机制
   Unix系统采用虚拟内存地址空间的机制，就是每个进程先天都拥有0-4G(32位系统)的虚拟内存地址，虚拟内存地址与物理内存没有直接的关系，本质就是一个整数。虚拟内存地址初始时不能存储数据，否则就会产生段错误。虚拟内存地址 必须 先做内存映射，映射到物理内存或硬盘文件后 才能 存储数据。程序员所接触到的内存地址其实都是虚拟内存地址。
   0-4G的虚拟内存地址空间分为用户空间和内核空间，用户空间0-3G，内核空间3G-4G(可以改变大小)。用户程序运行在用户空间，内核空间只有系统内核才能访问，用户程序不能直接访问内核空间。但内核提供一些系统函数负责从用户空间进入内核空间。
  内存地址的基本单位是字节，内存映射的基本单位是 内存页；目前主流的操作系统一个内存页是 4k (4096)字节。 getpagesize()可以获取内存页的大小。

  在Linux系统中，几乎一切都可以看成文件，包括：目录、内存和各种输入输出设备。在/proc目录下， 每个进程都有一个自己的目录，以进程的PID为名称。进程存在，目录就存在；进程结束，目录也消失。函数getpid() 可以获得当前进程的PID。
  进程存在时 可以用cat  /proc/PID/maps 查看内存的映射情况。

  进程的内存区域排序如下：(升序)
   代码区  
   只读常量区
   全局区
   BSS段   
   堆区
   栈区  -  在3G左右的位置

  任何的程序员都需要使用 数据结构和字符串，处理字符串的能力是程序员的基本功。
   C语言中的 字符串。
   在C语言中，字符串可以有三种形式：
    字面值 - "aaa"
    char*  - 字符指针
    char arr[] - 字符数组
   字面值存储在只读常量区，相同字面值的字符串在只读常量区只存一份。    
  char* s1 = "abc";  //在只读常量区创建一个abc
  char* s2 = "abc";  //直接返回上一行的abc
   s1 == s2 成立
  字符指针 代表 字符串是最常用的方式之一，指针指向的区域决定了字符串的特点。
  字符数组 代表 字符串是最常用的方式之一，字符数组是一个常指针，除了声明时可以使用=赋值，其它时候都不允许用 = 赋值。
  字符串 其实就是一个首地址，以'\0'作为结束。
  


