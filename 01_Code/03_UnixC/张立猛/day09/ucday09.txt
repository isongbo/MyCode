回顾：
  进程管理 
  信号  
    进程的退出 正常退出、非正常退出
    正常退出可以在 主函数执行return语句、exit()、_Exit()
    wait()和waitpid()
     waitpid()包含了wait()的功能，又提供了更多的选择。
     pid_t waitpid(pid_t pid,int* status,int options)
      pid可以指定 等待哪些/那个 子进程
      status可以获得结束子进程的退出方式和退出码
      options 可以选择等待或不等待
      返回等到的子进程的PID，出错返回-1。如果options设为WNOHANG(非阻塞)，有可能返回0。
    vfork()+execl() 
- 可以启动全新的子进程，vfork()创建子进程，execl()提供代码和数据。
   信号 - 用于 程序的中断，就是中止当前的代码，改为执行其他的代码。信号本质就是非负整数，Linux 0-64，中间不连续。1-31是不可靠信号，不支持排队，有可能丢失；34-64是可靠信号，支持排队，不会丢失。
   信号的处理方式 
    1 默认处理
    2 忽略信号
    3 程序员自定义处理函数
   函数 signal()/sigaction() 可以设置信号的处理方式，其中signal()更常用。设置信号处理方式的步骤：
   1 #include <signal.h>
   2 写信号的处理函数，格式： void fa(int signo){  }
   3 调用 signal(signum,fa) 把信号的处理方式改为 fa()。

今天：
  信号 - 信号的发送函数、子进程的信号处理、信号集、信号屏蔽、一些和信号相关的函数
  IPC - 进程间通信(进程之间的数据交互) : 管道
  
  通过fork()创建的子进程的信号处理方式 完全继承父进程的信号处理方式，如果父进程默认，子进程也默认，如果父进程忽略，子进程也忽略，如果父进程自定义，子进程也用父进程的处理函数。因为子进程 复制了 父进程的 内存空间。
  通过 vfork()+execl()创建的子进程的信号处理方式 部分继承父进程的处理方式，如果父进程默认，子进程也默认，如果父进程忽略，子进程也忽略，如果父进程自定义处理函数，子进程改成默认。因为子进程 不复制父进程的内存空间，所有没有处理函数。

   信号的发送方式：
    1 键盘发送(部分)
      Ctrl+C  信号2
      Ctrl+\   信号3
      ....
    2 系统出错(部分)
      段错误、总线错误、整数被0除 ....
    3 用kill 命令发送(全部)
      kill -信号 进程PID
    4 系统函数发送(全部)
     raise() / kill() / alarm() / sigqueue() ...
     sigqueue() 功能最强，代码也最复杂，需要和sigaction()结合
     主讲kill()
      int kill(pid_t pid,int signo)
      参数 pid 就是信号的接收进程，signo就是发送信号的值
      pid 可以为以下四种情况：
        -1    给所有有权限的进程发送信号
        >0   给指定进程发信号(进程ID=pid的)
        <-1  给进程组ID=pid的绝对值的 所有进程(有权限的)
        0     给和当前进程一组的所有进程(有权限的)
      注: 可以用kill -0 PID 测试是否有发送信号的权限。
 
    killall 程序名   (killall a.out)
     删除所有该程序启动的进程。
    
    alarm()是 系统闹钟的函数，n秒后产生一个闹钟信号(SIGALRM)
    sleep()会被 非忽略的信号打断，返回剩余的描述；如果没有被信号打断将返回0。
    usleep()比sleep()精确的多，以 微秒 为 休眠的单位。 

   信号集 - 多个信号可以存在信号集中，信号集就是信号的容器。
    信号集 类型 是sigset_t ，可以认为是一个超大的整数。
    数据结构的共性：(信号集也是一种数据结构)
     1 逻辑结构 - 逻辑上的结构(人脑中对该结构的设计)
     2 物理结构 - 计算机底层的结构(计算机内存中怎么设计)
     3 运算结构 - 提供哪些函数进行运算
    运算结构主要就是： 内存的分配和回收函数、元素的增删改查函数、其它函数(比如排序)。其中修改元素的函数不一定要提供。
    信号集就不需要修改函数，因为修改就是 增加或删除。内存的分配和回收 系统已经搞定。所以sigset_t运算结构只要记住：增删查。
    sigaddset() - 增加一个信号，把对应二进制位 置1
    sigfillset() - 增加所有的信号，所有二进制位 全置1
    sigdelset() - 删除一个信号，把对应二进制位 置0
    sigemptyset() - 删除所有的信号，所有二进制位 全置0
    sigismember() - 判断一个信号是否 在信号集中存在。

   信号n对应的二进制位 就是 倒数 第n位。

   信号屏蔽 
     程序员不能控制信号何时到来，信号随时可能出现。因此在执行一些关键代码，信号有可能会造成一些问题。有些关键代码应该是不能被信号打断的。使用 信号屏蔽可以实现关键代码不被信号打断。信号屏蔽不是 屏蔽信号的到来，而是 在信号到来的时候 暂时不做处理，等 解除了屏蔽以后再 处理。
    函数sigprocmask() 可以实现信号的屏蔽/解除屏蔽。
    int sigprocmask(int how,sigset_t* set,sigset_t* old)
     参数how是屏蔽的方式，包括：
     SIG_BLOCK - 相当于加法，原来的+传入的
       原来的 A B C +  传入的 C D E ->   A B C D E 
     SIG_UNBLOCK - 相当于减法，原来的 - 传入的
       原来的 A B C -  传入的 C D E ->   A B
     SIG_SETMASK - 直接设置，与原来的无关(最常用)
       原来的 A B C -  传入的 C D E ->  C D E 
     set 就是传入的信号集(被屏蔽的信号)，old就是用于传出之前屏蔽的信号集。old 可以用于解除信号屏蔽。关键代码执行完毕后，再次调用sigprocmask(old) 就解除了信号屏蔽。

   sigaction()函数(了解) - signal()函数的底层是调用了sigaction(),sigaction() 还提供了更强大的处理函数，可以包括信号的更多信息。

   计时器 (了解)
    Linux系统为 每个进程提供了三种计时器，真实计时器、虚拟计时器和实用计时器。真实计时器比较常用。
    计时器就是 xx秒之后每隔xx秒就产生一个信号。
    计时器的编程使用函数： setitimer() / getitimer() (设置和获取)
    
    IPC - 进程间通信 (应用更关键)
     进程和进程之前虽然 虚拟内存地址一样，但映射的物理内存完全不同，所以进程之间直接的数据交互无法实现的。实现进程间数据交互的技术有很多，统称为 进程间通信(IPC)。 
    常见的IPC技术包括：
     1 文件
     2 信号(signal)
     3 管道
     4 共享内存
     5 消息队列
     6 信号量集(semaphore)
     7 网络编程(socket)
    ....
    IPC 技术就是找到一个合适的交互媒介，两个进程都通过媒介进行数据的交互。
    管道 是 Unix 最古老的IPC技术，现在 较少使用。历史上的管道是半双工的，现在都支持全双工。管道是以 管道文件 作为交互的媒介的。管道分为有名管道和无名管道。有名管道就是程序员创建管道文件做交互，无名管道就是系统创建管道文件做交互。有名管道可以用于任意进程间的IPC，无名管道只能用于fork()创建的父子进程之前的IPC。
    管道文件(.pipe)是一种特殊的文件，用 touch/open() 无法创建，必须使用 mkfifo命令或 mkfifo()函数创建。管道文件是数据交互的载体，自身不会存储数据，只有读写管道都畅通时，管道文件才可用，否则 就会阻塞。
     管道的编程步骤：
      1 用mkfifo 创建一个管道文件
      2 用读写文件的代码 实现IPC。
    练习：
     使用管道文件a.pipe实现进程间通信，发100个int 过去就可以。



   





