回顾：
  环境表相关函数 ： getenv() setenv() unsetenv() putenv()
  Unix/Linux的内存管理：
   1 进程内存空间包括：
    代码区、只读常量区、全局区、BSS段、堆区、栈区
   2 虚拟内存机制：
    看图
   发生段错误的主要原因：
    1 使用了没有映射的虚拟内存地址。
    2 对内存执行了没有权限的操作，比如：修改只读区。
   3 内存管理的相关函数和运算符
    C程序员内存管理的6个函数：
    malloc() free()   sbrk() brk()   mmap() munmap()
今天：
   malloc() 和 free() 
   malloc() 分配堆区内存，是标C函数。
    void* malloc(int size)  参数是分配的大小，返回首地址(虚拟)。
   分配内存需要考虑两件事情：
    1 分配虚拟内存地址，以字节为单位
    2 映射物理内存，以内存页为单位
   注：分配的虚拟内存地址和映射的物理内存大小有可能不同。
    malloc() 一定会分配虚拟内存地址，但不一定映射物理内存。

   malloc()如果申请小块内存(少于31个内存页)，多映射33个内存页；如果超过33页，再重新映射33个内存页。如果申请大块内存，会映射比申请的稍多的内存页。
   malloc()分配的内存是不连续的，除了数据本身之外，还需要额外存储一些数据和留一些空。这些额外的数据以一个双向链表的形式存储，free()时就从额外数据中取到释放内存的大小。

   注意：使用malloc()不要超界，否则影响下一个变量。

   free() 一定会回收虚拟内存地址，但不一定解除物理内存的映射。最后33个内存页只有进程结束时才回收。

  经验：在应用中，malloc()和free()不用考虑太多，只是正常分配内存、正常回收即可。

   sbrk() 和 brk() - Unix系统函数
    sbrk()/brk() 和 malloc() 机制完全不同，底层依赖于系统管理的一个位置。 
    void* sbrk(int increment) 
    参数是增量，如果为正，分配increment字节的内存；如果为负数，就回收内存；如果参数为0，不分配也不回收，而是取当前的位置
   返回值:  成功返回移动之前的位置(内存的首地址)，失败返回(void*) -1。
    当sbrk()分配内存时，需要考虑两件事情：
    1 虚拟内存地址的分配，以字节为单位
    2  物理内存的映射，以内存页为单位
   一次映射1个内存页(申请多少就凑多少页)，不是33个内存页。
   当位置回到初始位置时，虚拟地址全部释放，物理内存的映射解除

   sbrk()函数分配内存时比较便利，但释放内存时需要自己计算，比较的麻烦。brk()函数则相反，分配内存比较麻烦，回收内存便利。

  int brk(void* p)
   参数就是新位置，不论之前的位置在哪里。
   返回： 成功0，失败 -1 。

  经验：
    开发时，用sbrk()分配内存，用brk()释放内存。
  练习：
    改变刚才的代码，实现用sbrk()分配、brk()回收内存。
    写一个sbrkbrk.c，用sbrk()分别分配int、double、char*三个变量，然后存入数据，打印数据后，用brk()释放三个变量。

  mmap()和munmap() - 内存映射(映射物理内存或硬盘文件)

   位或 | 用来连接多个选项或多种权限。位或 与0做位或结果不变，与1做位或 结果恒定为1。prot权限就写成 PROT_READ|PROT_WRITE。
  
  void* mmap(void* addr,size_t size,int prot,int flags,
    int fd,offset_t offset)
   参数 addr可以指定映射的首地址，一般给0即可，交给内核选择
     size 就是映射的大小，不足一个内存页的会补齐一页。
     prot指定是内存的权限，一般写PROT_READ|PROT_WRITE
     flags可以设置一些标识，主要包括：
      MAP_PRIVATE   MAP_SHARED : 必选其一，MAP_SHARED只用于映射硬盘文件，表示其他进程可以查看到文件中的数据。MAP_PRIVATE 可以映射内存和文件，表示其他进程不可以查看数据。
     MAP_ANONYMOUS ： 表示映射物理内存，不写就是映射文件
    fd 是文件描述符，offset是映射的偏移量，这两个参数都是映射文件时使用，映射物理内存时 给 0 即可。
   返回值：成功返回首地址，失败返回 MAP_FAILED即(void*) -1

  系统调用(System Call) - 用户程序无法直接进入内核空间，必须借助一系列的系统函数才能进入内核空间；这一系列的系统函数统称为系统调用。
  文件和目录
   文件描述符 - 标C用 FILE* 代表一个打开的文件，UC使用 文件描述符代表一个打开的文件，这个文件描述符本身就是一个整数。
   各种函数 - 读写相关函数、非 读写函数。 
   读写相关函数：
    标C读写文件的套路： fopen() fread()/fwrite() fclose()
    UC读写文件的函数：
     1 打开一个文件 open()
     2 读写文件 read()/write()
     3 关闭打开的文件 close()
    注：这4个函数不只是能操作文件，还能操作其他的设备。比如读写函数除了能读写文件，也可以读写网络数据。
    int open(char* filename,int flags, ...)
     参数 filename 就是文件名(带路径)，flags是打开的标识，主要包括：
     O_RDONLY   O_WRONLY  O_RDWR ：读写权限，三必选一
     O_CREAT : 如果文件存在打开，不存在可以新建
     O_EXCL ： O_CREAT的辅助，效果是 文件不存在新建，存在就返回错误(-1)
     O_TRUNC : 打开文件的同时 把文件的内容清空
     O_APPEND ： 以追加的方式打开文件，一般用于追加写。
    ... 代表 0-n个任意类型的参数，如果是新建文件必须使用，传入新文件的权限(文件在硬盘上的权限)，如果是 打开已存在文件 不使用。
   返回：成功返回 文件描述符，失败返回 -1 。
   多个选项 用 位或 | 连接。
   close(int 文件描述符)
   
   int read(int fd,void* buf,size_t size)
   int write(int fd,void* buf,size_t length)
    参数： fd 就是文件描述符，open()的返回值
     buf就是读/写的内存的首地址
     size是buf的容量，将来不一定会读这么多。
     length是 数据的真实的长度，直接决定了写入多少数据。
    返回：read() 成功返回实际读到的字节数，失败返回-1 ， 0代表读到了文件尾。
   
   使用vi时，vi有可能在文件的末尾加换行，但write()不会。

  作业：
    1 回去把string.c 熟悉起来，敲5遍。
    2 用UC的读写函数实现一下文件的拷贝，要求写通用的代码，可以拷贝任何类型的文件，可以用 图片或压缩文件测试。
    
提示： 拷贝文件就是从一个文件读，写入另外一个文件。



