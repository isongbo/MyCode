复习：
1.内存管理
1.1 内存区域
   代码区  只读常量区 全局区  BSS段  堆区  栈区

结论：
   对于指向只读常量区的指针来说，可以改变指针的指向，不可以指向地址上的内容;对于数组来说，可以改变数组中的内容，但是不可以数组名的指向;对于指向堆区的指针来说，既可以改变内容有可以改变指向

1.2 虚拟内存地址和物理内存地址
   unix/linux系统采用虚拟内存管理技术进行虚拟地址和物理内存空间的映射
   对于每一个进程来说，一般拥有0 ~ 4G内存空间，分为两部分：0~3G 用户空间  3G~4G 系统空间
   
1.3 段错误的原因
   (1)使用没有建立映射虚拟地址
   (2)对没有操作权限的内存进行操作
   (3)空指针和野指针的使用

1.4 使用malloc进行内存的申请
   malloc申请的内存空间之间可能需要额外的12个字节用来存储内存的管理信息
   malloc申请内存时，如果申请的不足33个内存页，一般默认分配33个内存页，一个内存页的大小一般都是4k(4096字节)
,超过之后再扩一倍

1.5 使用free函数释放内存
   一般来说，释放多少则在内存中减去多少，free所有内存之后也可能保留33个内存页，保证虚拟地址由已经使用变为没有使用   
-----------------------------------------------------
今天内容：
   (1)内存管理相关的函数
   (2)文件操作以及相关的函数

1.内存管理相关的函数
(1)sbrk函数
   time_t  size_t ....  本质上都是基本数据类型/复合数据类型的别名,看作int/unsigned int去使用 
   #include <unistd.h>
   void *sbrk(intptr_t increment);
参数：表示一个增量,也就是内存的大小
      正数  表示申请内存
      0     获取当前位置
      负数  表示释放内存
返回值：前一个地址，也就是申请内存之前的首地址
        失败返回(void*)-1
函数功能：增加内存的字节数，如果参数传0表示获取当前指
      针的位置，也就是新位置

注意：
    (1)使用sbrk函数申请内存时，如果内存大小不足一个内存页时，一般给分配一个内存页的大小，一旦超过一个内存页的大小，则再分配一个内存页的大小，也就是分配内存的基本单位是内存页
    (2)使用sbrk释放内存时，返回值无意义，一般更多用于申请内存

(2)brk函数
   #include <unistd.h>
   int brk(void *addr);
函数功能：
   表示将内存空间扩展到addr所指向的位置,成功返回0，失
   败返回-1

注意：
   sbrk函数申请内存比较方便，释放比较麻烦，brk函数申请内存比较麻烦，释放比较方便，所以这两个函数搭配使用，
sbrk函数负责申请内存，brk函数负责释放内存

练习：
   使用sbrk函数分配内存，使用brk函数释放内存，分配一个int类型的空间存放整数88,再分配一个double类型的空间存放3.1415926,再分配一个长度为10的字符数组空间存放字符串"hello",打印三个变量的值，以及释放全部内存

(3)mmap函数
   #include <sys/mman.h>
   void *mmap(void *addr, size_t length, int p
rot, int flags,int fd, off_t offset);
第一个参数：建立映射的起始地址，给NULL即可，由内核指定
第二个参数：映射的地址空间的长度
第三个参数：访问权限
     PROT_READ - 可读的
     PROT_WRITE - 可写的
第四个参数：是否可见的标志
     MAP_SHARED - 共享的
     MAP_PRIVATE - 私有的，映射物理内存使用
     MAP_ANONYMOUS - 表示映射物理内存
第五个参数：
     文件描述符,映射物理内存时给0即可
第六个参数：
     文件的偏移量，映射物理内存时给0即可
返回值：
     成功返回映射虚拟内存的地址，失败返回
     MAP_FAILED((void*)-1)     
函数功能：
     建立虚拟内存地址到物理内存/文件的映射

(4)munmap函数
   int munmap(void *addr, size_t length);
函数功能：
    解除addr所指向的大小为length的映射，成功返回0，失
    败返回-1
复习：  
    ls -l
    文件类型 rwx  7 => 111 => 011 => 3
    r - 4 -> 2^2
    w - 2 -> 2^1
    x - 1 -> 2^0   
    r | w 
  => 100
  => 010
  => 110
  => 6

2.系统调用的概念
   系统调用就是操作系统内核对外的一些列接口函数，当外部函数调用系统调用函数时，会通过软中断的方式把地址空间从用户空间切换到内核空间，执行具体的系统调用函数，从而操作内核，等系统调用函数结束之后，会由系统内核空间切换回到用户空间

3.文件操作
3.1 概念和基础知识
   linux系统下,几乎所有的一切都可以看作文件,因此，对于文件的操作 基本上适用于各种输入输出设备,包括目录也是文件

如：
   /dev/null  空设备
   /dev/tty   终端，输入输出设备
   echo 字符串 - 将字符串打印出来,回显内容
   echo hello > a.txt - 将hello写入a.txt文件中
   cat a.txt - 查看文件a.txt的内容
   more a.txt - 分屏查看文件a.txt的内容
   echo hello > /dev/null 表示丢弃字符串hello
   cat /dev/null > a.txt  表示清空文件a.txt
   echo hello > /dev/tty 表示输出到终端
   cat /dev/tty  表示从终端中读取内容

3.2 相关函数
复习标C中文件操作函数：
    fopen()/fclose()/fread()/fwrite()/fseek()/...
(1)open函数
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   int open(const char *pathname, int flags);
   int open(const char *pathname, int flags, mode_t mode);
   int creat(const char *pathname, mode_t mode);
以第二个open函数为例解析如下：
第一个参数：文件的路径以及文件名
第二个参数：标志，访问模式
     O_RDONLY - 只读
     O_WRONLY - 只写
     O_RDWR   - 可读可写
     
     O_CREAT  - 文件不存在则创建
     O_EXCL   - 一般与O_CREAT搭配使用，表示如果文件存
          在则open函数调用失败
     O_TRUNC  - 文件存在且有可写权限，则清空文件
     O_APPEND - 追加的方式打开文件 >>     
第三个参数: 用于创建新文件时指定文件的权限,否则不需要
     类似于 ls -l的功能 0666  属主 属组 其他人
返回值：
     成功返回新的文件描述符(文件的编号)，失败返回-1
函数的功能：
     打开/创建一个文件/设备

(2)close函数
   #include <unistd.h>
   int close(int fd);     
函数功能：表示关闭fd所指向的文件

(3)read函数
   #include <unistd.h>
   ssize_t read(int fd, void *buf, size_t count);
第一个参数：文件描述符
第二个参数：缓冲区地址
第三个参数：数据的大小
返回值：成功读取的数据大小
函数功能：从fd指向的文件中读取count字节的数据，然后存
     放到buf指向的内存中

(4)write函数
   #include <unistd.h>
   ssize_t  write(int  fd,  const void *buf,size_t count);
函数功能：
    表示将buf中的count个字节的数据写入fd指向的文件中，成功返回写入的数据大小，失败返回-1	

练习：
   编程实现以下功能：
员工信息：员工编号，姓名，薪水,采用结构体
(1)把一个/多个员工信息存入文件emp.dat,编写文件
   writeemp.c,要求员工信息从控制台输入
(2)编写文件reademp.c,要求将文件emp.dat中的员工信息读取
   出来打印到屏幕上

明日预报：
    文件操作的相关函数








         
   










   








      

























