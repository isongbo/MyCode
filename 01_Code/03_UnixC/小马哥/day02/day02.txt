复习：
1. unix/linux系统简介
   unix系统诞生于1971年  贝尔实验室 
   unix系统 支持多用户、支持多任务、支持多种处理器
   linux系统 在unix系统基础上诞生的，免费的

2.gcc编译器
2.1 概念
   gcc原来的名字 GNU C 编译器，后来支持了C++等语言，GNU 编译器的集合

2.2 功能
   gcc主要用于 预处理  编译  汇编  链接 
   预处理 - 进行头文件的包含以及宏替换
   编译 -  检查语法错误
   汇编 - 生成汇编文件
   链接 - 生成可执行文件

2.3 常用选项
   -E   -c  -S  -o  -std  -g  -O  -Wall

2.4 常用的文件类型
   .c   .h   .i   .s  .o  .a  .so

3.多文件结构和预处理指令
3.1 多文件结构
    .h   .c    .a   .so
3.2 预处理指令
    #line     #warning   #error   
    #pragma  GCC  dependency 文件名
    #pragma  GCC poison 标识符
    #pragma  pack(整数)

4.环境变量
    PATH 里面配置了某个可执行文件的路径时，则执行可执行文件时就可以不加路径直接运行
    export PATH = .:$PATH  一次性的
    vi ~/.bashrc     source ~/.bashrc
-------------------------------------------------------    
今天内容：
   (1)C程序相关的环境变量
   (2)静态库和动态库的使用
   (3)C程序中的错误处理
   (4)程序中的错误编号以及原因
   (5)环境表
   (6)再见main函数
   (7)内存管理的初识

1.C程序相关的环境变量
1.1 环境变量
   CPATH - C语言的头文件的路径
   LIBRARY_PATH - 定位静态库的路径
   LD_LIBRARY_PATH - 定位共享库的路径

1.2 头文件的查找方式
(1)<> 包含的头文件表示从系统指定的目录中去查找
    默认情况下  /usr/include/...      
(2)"" 包含的头文件表示从当前工作目录中去查找
(3)可以通过配置环境变量CPATH来设置头文件的路径
如：
     export CPATH = ..
     export CPATH = $CPATH:..  可以将头文件放在上一级目录中    
(4)可以通过-I的编译链接选项去查找头文件
如：
     cc *.c -I 头文件的路径

2.静态库和共享库的使用
   为了调用者使用方便，程序不要直接提供.c文件/.o文件，而是将相关的.o文件打包成一个或者多个库文件，编写者只需要提供库文件和头文件即可
   库文件主要分成两种：静态库 和 共享库

2.1 静态库和共享库
(1)静态库
   静态库文件在使用的过程中，直接把代码复制到目标文件中，优点就是使用简单，所有的代码都集中于一个文件中，效率比较高;缺点就是此文件会比较大，不利于修改     
(2)共享库
   共享库文件在使用的过程中，将代码对应的地址复制到目标文件中，优点是：目标目标比较小，不需要占用太大的空间，比较有利于修改；缺点是：使用比较麻烦，效率比较低，运行时需要依赖于共享库文件，一般项目中采用此方法

2.2 进行静态库的打包
(1)编写源代码xxx.c
如：  
    vi 01add.c  编写源代码
(2)只编译依赖文件,生成.o文件
如：
    cc -c 01add.c
(3)将.o文件打包成静态库文件
如：
    ar -r lib库名.a 01add.o 生成静态库文件
注意：
   (1)静态库文件的名字格式：用lib开头，用.a为后缀   
   (2)库名和静态库文件名不同

2.3 使用静态库文件
(1)编写测试程序
如:
   vi main.c 
(2)只编译不链接测试文件，生成.o文件
如：
   cc -c main.c 
(3)连接测试程序和静态库文件,有三种方法
   a.直接连接
      cc main.o libadd.a
   b.间接连接
      cc main.o -l 库名 -L 静态库文件所在的目录(掌握)
   c.配置静态库文件
      export LIBRARY_PATH = .  省略-L选项   

2.4 共享库的打包流程
(1)编写源程序 xxx.c
如：
   vi 01add.c 编写源代码
(2)编译源程序,生成xxx.o
如：
   cc -c -fpic 01add.c 生成01add.o文件
(3)根据xxx.o文件生成共享库文件
如：
   cc -shared 01add.o -o lib库名.so 生成共享库文件

2.5 共享库的使用步骤
(1)编写测试文件xxx.c
如：
   vi main.c
(2)编译测试文件
如：
   cc -c main.c  生成main.o文件
(3)连接共享库,有三种方法：
   a.直接连接
     cc main.o lib库名.so
   b.间接连接
     cc main.o -l 库名 -L 共享库文件的路径
   c.配置共享库的环境变量
     export LD_LIBRARY_PATH=.
     cc main.o -l 库名
注意：
   对于共享库文件来说，必须配置环境变量LD_LIBRARY_PATH的值

练习：
   编写一个函数，实现比较两个int类型的参数大小，然后将较大的数返回，分别使用静态库和共享库两种方法调用 
   mkdir max  
   vi max.h   vi max.c   vi main.c  

2.6 查看共享库文件
   使用ldd a.out 查看a.out文件中连接的库以及调用关系

2.7 采用打开普通文件一样的方式使用共享库
(1)dlopen函数
  #include <dlfcn.h>
  void  *dlopen(const  char  *filename, int flag);
第一个参数：共享库的文件名
第二个参数：打开方式/加载方式
     RTLD_LAZY  延迟加载
     RTLD_NOW  立即加载
返回值：返回共享库文件的handler,理解为地址即可
函数功能：按照指定的方式加载共享库文件
        
(2)dlerror函数
   char *dlerror(void);
函数功能：
   判断其他三个函数是否出错，返回NULL表示没有出错

(3)dlsym函数
   void  *dlsym(void  *handle,  const   char *symbol);
第一个参数：dlopen函数的返回值
第二个参数：要查找的标识符
返回值：返回标识符的地址
函数功能：根据参数handle查找共享库中的标识符symbol

(4)dlclose函数
   int dlclose(void *handle);
函数功能：关闭handle所指向的共享库文件

注意：
   编译连接程序的时候需要加： -ldl

3.C语言的错误处理
  对于C程序来说，一般而言都通过函数的返回值进行判断程序是否出错,判断的一般原则如下：
    (1)如果函数的返回值是指针类型，NULL代表出错，也就是0,比如:fopen
    (2)如果函数的返回值是int类型，并且返回值不可能是负数的时候，则可以用-1代表出错
    (3)如果函数的返回值是int类型，并且返回值可能是负数的时候，需要通过指针作为参数将结果带出来，返回值表示是否出错，可以使用-1代表
如：
    int max(int i,int j,int* pi)
   (4)如果不考虑是否出错，返回值为void即可

练习：
   (1)编写一个函数，实现返回1~10之间的随机数，如果随机数是5，则返回错误
   (2)计算两个int类型参数的最大值，如果相等，返回错误
   (3)传入一个字符串，如果传入的字符串是"error",返回错误，否则返回"ok"
   (4)打印传入的字符串即可
   vi 02error.c

作业：
   (1)思考：指针作为函数的参数是如何将结果带出来的？
   (2)编写两个函数分别实现打印一个空心菱形和实心菱形，分别打包成静态库和共享库进行调用
      ****
       *  *
        *  *
         ****

明日预报：
   (1)错误编号和错误信息
   (2)环境表和主函数
   (3)内存管理



  
  

           




