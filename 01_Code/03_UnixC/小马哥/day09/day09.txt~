复习：
1.目录操作
  mkdir - 创建目录的函数
  rmdir - 删除目录的函数
  chdir - 切换目录的函数
  opendir - 打开目录的函数,返回值DIR*
  readdir - 读取目录中的内容,struct dirent*类型
        d_type 文件的类型   d_name 文件的名称
        4 - 目录     8 - 普通文件
  getcwd - 获取当前进程的工作路径,可以通过参数带出去，
        也可以通过返回值返回

2.进程 和 多进程
2.1 基础知识
    ps - 显示当前终端启动的进程
    ps -aux  显示全部的进程信息
    ps -ef   全格式的方式去显示   
如：
    PID - 进程号,进程的唯一标识
    CMD - 进程指令
    USER - 用户名
    PPID - 父进程的进程号

    kill -9  进程号 - 杀死指定的进程

    一般来说，系统内部进程0,负责启动进程1和2,其他的进程都是由1和2直接或者间接启动起来
    进程A启动了进程B，A是B的父进程，B是A的子进程

2.2 相关的函数
   getpid()  - 获取当前进程的进程号
   getppid() - 获取当前进程的父进程号
   getuid() - 获取用户id
   getgid() - 获取组id

   fork() - 以复制当前进程的方式去创建新的子进程，函数有两个返回值，子进程返回0,父进程返回子进程号,-1是失败
   fork函数创建的子进程会复制父进程中除了代码区的内存区域，代码区和父进程共享
   父子进程的关系

2.3 进程的终止
正常终止：
    (1)在main函数中执行了return
    (2)调用了exit()函数
    (3)调用了_Exit() / _exit()函数
    (4)最后一个线程返回了
    (5)最后一个线程调用pthread_exit()函数
非正常终止：
    (1)采用信号终止
    (2)最后一个线程被其他线程取消

2.4 终止函数的区别
    _Exit()  -  标C函数，立即终止
    _exit()  -  UC函数,立即终止
    exit()    -  调用atexit(),atexit()调用另外一个函数

2.5 进程的等待
    wait() - 等待任意一个子进程结束
       => waitpid(-1,&status,0)
    waitpid() - 等待指定规则的子进程结束
    通过返回值体现了哪个进程结束了,通过退出码来区分因为何种原因终止
    WIFEXITED - 判断是否正常终止
    WEXITSTATUS - 获取退出码
------------------------------------------------------
今天内容：
   (1)多进程的相关函数
   (2)中断的概念
   (3)信号和信号的处理

1.多进程的相关函数
(1)vfork函数
   #include <sys/types.h>
   #include <unistd.h>
   pid_t vfork(void);
函数的功能：
   和fork函数类似，但是不会复制父进程的内存区域，而是直接占用父进程的内存空间，会导致父进程进入阻塞状态，从而保证了子进程先执行

(2)exec系列的函数
   #include <unistd.h>
   int execl(const char  *path, const  char *arg, ...);
第一个参数：文件的路径和文件名
第二个参数：一般指定执行文件的命令
第三个参数：可变长参数,一般指定执行命令附带的选项
返回值：失败返回-1
函数的功能：按照参数的要求去执行一个文件
如：
    whereis ls -> 查看ls命令所在的路径
    execl("/bin/ls","ls","-l",NULL);

注意：
    vfork函数和exec系列函数搭配使用，其中vfork函数主要负责创建新的子进程，而exec系列函数主要用于执行新的程序，从而可以让子进程去执行与父进程所不同的代码

(3)system函数
   #include <stdlib.h>
   int system(const char *command);
函数的功能：
   表示按照参数指定的shell命令执行，失败返回-1

2.中断的概念
   暂时停止当前程序的执行转而执行新的程序或者处理新的意外情况
   中断分为：硬件中断  和  软件中断

3.信号和信号的处理
3.1 概念
(1)概念
   信号就是一种软件中断,信号既可以作为进程间的通信方式，也可以用于中断某个进程的执行，可以处理意外情况
如：
   ctrl+c  段段错 总线错误 ...都是信号

(2)信号的特点：
   信号是异步的,进程可以处理信号，也可以发送信号,每个信号都有一个名字，并且以SIG开头,比如：ctrl+c SIGINT  
      
(3)信号的命令以及信号的值
a.查看信号的命令
  kill -l  - 显示当前系统下所有信号
如：  
   SIGINT  2   使用ctrl+c发送此信号
   SIGQUIT 3   使用ctrl+\发送此信号
   SIGKILL 9   用户不能捕捉此信号

b.信号的分类
   当前linux系统下信号的范围: 1 ~ 64,其中32、33不存在
其中1 ~ 31之间的信号 叫做不可靠信号，34~64之间的信号叫做可靠信号
   不可靠信号：表示不支持排队，信号可能会丢失，也叫做非实时信号
   可靠信号：表示支持排队，信号不会丢失，也叫做实时信号

3.2 信号的处理方式
  (1)默认处理, 绝大多数信号的处理方式都是终止进程
  (2)忽略处理
  (3)自定义处理信号

注意：
   a.信号9只能进行默认处理，不能忽略也不能自定义处理
   b.信号的发送受到用户的限制，每个用户只能给自己的进程发信号进行处理,root用户可以给所有用户的进程发信号

3.3 信号处理函数
   #include <signal.h>
   typedef void (*sighandler_t)(int);
   sighandler_t signal(int  signum, sighandler_t handler);

解析：
   typedef void (*)(int) sighandler_t;
   void (*)(int) signal(int  signum, void (*)(int) handler);

=> void (* )(int) signal(int  signum, void (*handler)(int));

=> void (*  
       signal( int signum,void (*handler)(int) )
        )(int)
=> signal是一个函数
=> 函数的第一个参数是int类型的,第二个参数是函数指针
=> 返回值首先是一个指针,其次是一个指向函数的指针,也就
   是函数指针
综上所述：
   signal是一个函数，具有一个int类型参数，一个函数指针类型参数，并且返回值类型也是函数指针的 函数
   函数指针是一个 指向具有int类型参数，和void类型返回值的函数 的指针

解析函数的功能：
   第一个参数：信号值/信号名称
   第二个参数：信号的处理方式
       SIG_DFL - 默认处理，绝大多数都是终止进程
       SIG_IGN - 忽略处理
       自定义函数名 - 自定义处理
   返回值：失败返回SIG_ERR
   功能：对指定的信号设置指定的处理方式

3.4 父子进程对信号处理的比较
   (1)使用fork创建的子进程 照搬父进程中信号的处理方式，父进程默认处理，子进程也默认，父进程中自定义处理，子进程也自定义处理，父进程忽略，子进程也忽略处理
   (2)使用vfork和execl函数搭配创建的子进程来说，父进程中忽略，子进程也忽略，父进程中默认处理，子进程也默认处理，但是父进程自定义处理，子进程采用默认处理

如：
   void print(int i,int * pi)
   {
       *pi = i;
   }

  int res = 0;
  int res2 = 0;
  print(2,&res2);
  res2 = 2

3.5 发送信号的方式
(1)键盘发送(只能发送一些比较特殊的信号)
   ctrl+c  -> 信号2  SIGINT
   ctrl+\  -> 信号3  SIGQUIT
   ...
(2)程序出错(只能发送一些比较特殊的信号)
   段错误 -> 信号11 SIGSEGV
   总线错误 -> 信号7  SIGBUS
   ...
(3)使用kill发送信号
   kill -信号值 进程号 -> 可以发送所有的信号
(4)采用系统函数发送信号
   raise()/kill()/alarm()/sigqueue()

3.6 发送信号的函数
(1)raise函数
   #include <signal.h>
   int raise(int sig);
函数的功能：
    表示给调用进程/线程发送指定的信号，成功返回0，失败
    返回非0

   #include <unistd.h>
   unsigned int sleep(unsigned int seconds);
函数的功能：
   表示按照参数指定的秒数进行睡眠，直到睡够了指定的秒数或者一个不能忽略的信号到来，那么睡眠会被打断,如果睡眠的时间达到了则返回0，否则返回还没有来得及睡的秒数

(2)kill函数
   #include <sys/types.h>
   #include <signal.h>
   int kill(pid_t pid, int sig);
第一个参数：进程号
    0 表示把信号发送给当前进程同进程组中的每一个进程
   -1 表示把信号发送给每一个有发送信号权限的进程，除了
      进程1,也就是init进程 
  <-1 表示发送信号到id为-pid的同组每一个进程中
 正数 表示给进程号为pid的进程发信号(单发,重点)   

第二个参数：具体的信号值/信号名称
   0 表示用来检查指定的进程/进程组是否存在，以及是否有
     发送信号的权限

返回值：成功返回0，失败返回-1
函数的功能：给指定的进程发送指定的信号

(3)alarm函数
   #include <unistd.h>
   unsigned int alarm(unsigned int seconds);
函数的功能：
   表示按照参数指定的秒数之后发送SIGALRM,返回值是之前闹钟没有来得及响的时间，如果之前没有闹钟则返回0
   当参数为0时，表示不会设置新的闹钟，也就是取消闹钟

练习：
   模拟银行自动生成帐号的业务模块，要求：银行的第一个客户初始帐号为：100000,其他客户依次递增,100001,100002,....
提示：
   int generator_id(void)
   {
        //access()  判断文件是否存在
        //open()/read()/write()/close()
        //文件中只保留最后一个帐号即可
        //函数负责实现上述的功能
   }

明日预报：
   (1)信号集和信号的处理
   (2)进程间的通信




















   























   





   
  



   













