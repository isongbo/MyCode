复习：
1.错误编号和错误信息
1.1 错误编号
    函数的调用是否出错通过函数的返回值来体现，绝大多数函数一旦出错就会将错误原因通过错误编号体现，通过errno的全局变量来获取,#include <errno.h>

1.2 错误信息的相关函数
(1)strerror函数 
(2)perror函数        
(3)printf("%m")

注意：
   errno不能代表函数的调用是否出错!

2.环境表和主函数原型
2.1 环境表的概念
    环境表就是环境变量的列表，通过一个字符指针数组存储所有环境变量的首地址，根据最后一个元素为NULL表示数组已经到结尾了，通过全局变量 extern char** environ来获取环境表的首地址

2.2 环境变量的相关函数
(1)getenv 获取环境变量的值
(2)setenv 增加/修改环境变量的值
(3)putenv 增加/修改环境变量的值 name=value;
(4)unsetenv 删除环境变量
(5)clearenv 清空环境表

2.3 主函数原型
   int main(int argc,char* argv[],char** env){}
   argc : 参数的个数
   argv : 存储每一个参数的首地址
   env: 环境表的首地址

3.内存管理
3.1 程序和进程
   程序：一般存放在硬盘的文件
   进程：运行在内存中的程序

3.2 进程中内存区域划分
(1)代码区  
(2)只读常量区 
(3)全局区
(4)BSS段  
(5)堆区 
(6)栈区 
------------------------------------------------------
今天内容：
    (1)内存管理
    (2)文件操作

1.内存管理
1.1 进程中的内存区域划分
   代码区  只读常量区  全局区  BSS段  堆区  栈区

如：
    char* ps = "abcd";
    char str[10] = "abcd";   
综上所述：
    对于指向只读常量区的指针来说，可以修改指针的指向，但不可以修改指向的地址上的内容；对于数组来说，可以修改数组中的内容，但是不可以修改数组名的指向；对于指向堆区的指针来说，内容和指向都可以改变

1.2 虚拟内存地址和物理内存地址
    unix/linux系统的内存实际上采用虚拟内存管理技术进行管理的，即：每个进程都有0~4G的内存地址(虚拟内存地址，而不是物理内存地址)，由操作系统负责 把虚拟内存地址和物理内存地址 映射起来
    0~4G的虚拟内存地址空间分为用户空间和内核空间，用户空间0~3G，内存空间3G~4G(大小可以改变)，其中用户程序运行在用户空间，内存空间只有系统内核才可以访问，用户程序不能直接访问内核空间，但是内核空间提供了系统函数负责从用户空间进入内核空间
    内存地址的基本单位是字节(byte),内存映射的基本单位是内存页，目前主流的操作系统一个内存页大小是4Kb(4096个字节)

1.3 段错误的由来
(1)虚拟地址没有映射到真正的物理内存空间,可能引发段错误
(2)对没有操作权限的内存进行操作，可能引发段错误
(3)野指针和空指针可能引发段错误
    
1.4 内存分配
(1)malloc分配内存需知
    malloc函数申请内存空间时，除了指定的内存大小之外，可能需要额外的12个字节，而这12个字节用于存储一些管理内存的数据和相关信息，便于后期使用free释放内存   
    建议对malloc分配的内存空间不要进行越界操作，以免破坏相关的内存信息

(2)malloc分配内存大小
    malloc申请内存时,如果申请比较小的内存空间时，一般会按照33个内存页的内存空间进行分配，如果申请比较大的内存空间时(超过33个内存页),则会按照比所要申请的内存空间稍微多一点的方式进行分配
     ps -aux 用于显示当前操作系统中的进程详细信息
     ps -aux | more  分屏显示
     cat /proc/进程号/maps 查看内存的分配情况
     #include <unistd.h>
     getpid()  -  获取当前进程的进程号
     getchar() - 获取一个字符的输入    

1.5 内存的回收
    使用free函数进行内存的回收，使用malloc函数申请不到33个内存页时，一般默认分配33个内存页,如果申请的空间超过33个内存页时，一般分配66个内存页；使用free释放内存时，一般释放多少则减去多少内存空间，当所有内存释放完毕之后，可能保留33个内存页
    free不保证立即释放内存，只能保证虚拟内存地址由已经使用到没有使用

1.6 内存页的函数
    getpagesize() - 获取内存页的大小

1.7 unix/linux系统的底层内存管理函数
(1)sbrk函数
   time_t  size_t ....  本质上都是基本数据类型/复合数据类型的别名,看作int/unsigned int去使用 
   #include <unistd.h>
   void *sbrk(intptr_t increment);
参数：表示一个增量
      正数  表示申请内存
      0     获取当前位置
      负数  表示释放内存
返回值：前一个地址，也就是申请内存之前的首地址
函数功能：增加内存的字节数，如果参数传0表示获取当前指
      针的位置，也就是新位置

作业：
     查询 brk函数，将brk函数和sbrk函数进行比较,尝试调用函数编写代码

明日预报：
    (1)内存管理的相关函数
    (2)



















    







