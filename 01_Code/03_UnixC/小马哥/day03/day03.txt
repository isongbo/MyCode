复习：
1.编程相关的环境变量
1.1 环境变量
   CPATH - 头文件的路径
   LIBRARY_PATH - 静态库文件的路径
   LD_LIBRARY_PATH - 共享库文件的路径
1.2 查找头文件的方式
  (1)<> 包含的头文件表示从系统指定的路径中去查找
/usr/include 目录下
  (2)"" 包含的头文件表示从当前工作目录中去查找
  (3)配置环境变量CPATH
  (4)使用 -I 来指定头文件的路径    

2.库文件
2.1 比较
   库文件主要分为：静态库和共享库
   静态库:表示将库文件指令直接复制到调用文件中，优点是：效率比较高，并且可以脱离库文件；缺点：让调用文件显得比较大，不利于修改
   共享库：表示将库文件指令的地址复制到调用文件中，有点是：调用文件比较小，有利于修改;缺点是：效率比较低，不可以脱离库文件

2.2 静态库的生成流程
(1)编写源程序 vi xxx.c
(2)只编译不链接生成目标文件  cc -c xxx.c
(3)ar -r lib库名.a xxx.o

2.3 静态库的调用流程
(1)编写源程序 vi xxx.c
(2)只编译不链接生成目标文件 cc -c xxx.c
(3)连接静态库文件
     cc xxx.o -l 库名 -L 库文件的路径

2.4 共享库的生成流程
(1)编写源程序  vi add.c
(2)只编译不链接  cc -c -fpic add.c   
(3)生成共享库文件
     cc -shared add.o -o lib库名.so

2.5 共享库的调用流程
(1)编写源程序  vi main.c
(2)只编译不链接  cc -c main.c
(3)链接共享库文件
     cc main.o -l 库名 -L 库文件的位置
注意：
    要求必须配置环境变量  export LD_LIBRARY_PATH=.

2.6 基本命令
   ldd a.out  查看使用的共享库以及调用关系

2.7 使用打开文件的方式去使用共享库
   dlopen  dlerror  dlsym  dlclose

3.C语言错误处理
   (1)对于返回值为指针类型的函数来说，返回NULL表示出错
   (2)对于返回值为int类型的函数来说，如果返回值不可能为负数的话，使用-1代表出错
   (3)对于返回值为int类型的函数来说，返回值可能为负数的话，需要借助指针作为函数的参数将返回值带出去，让返回值表示成功还是失败
   (4)对于不需要表示是否出错的函数来说，那么只需要用void表示返回值类型即可

作业：
   (1)指针作为函数的参数如何将数据带出去？
------------------------------------------------------
今天内容：
   (1)错误编号和错误信息
   (2)环境表以及main函数原型
   (3)内存管理技术

1.错误编号和错误信息
如：
   fopen函数 - 打开一个文件，失败返回NULL

1.1 错误编号   
   函数的返回值可以代表出错，但是不能表示出错原因，而errno是个全局变量，用于储存出错原因所对应的编号，根据errno可以查看具体的错误原因
   /etc/passwd  文件中储存了账户和密码等信息
   用户名 密码 用户id 组id 注释  主目录  shell类型

1.2 错误信息
(1)strerror函数
   #include <string.h>
   char *strerror(int errnum);
功能：根据参数指定的错误编号来获取具体的错误原因字符
     串，通过返回值返回

(2)perror函数
   #include <stdio.h>
   void perror(const char *s);
功能：参数信息原样输出，自动获取最后一个错误原因进行打
    印，打印完毕之后自动换行

(3)printf函数
   printf("%m"); 表示按照格式打印错误信息，可以在%m的前面增加提示信息

注意：
    (1)绝大多数情况下都使用perror函数
    (2)判断函数的调用是否成功需要根据返回值进行判断，不能根据errno中是否有值来判断，绝大多数函数调用一旦出错，会自动将错误编号存放到errno中，根据errno获取错误原因

2.环境表以及主函数的原型
2.1 环境表
   环境表表示环境变量的集合，如:PATH CPATH LIBRARY_PATH LD_LIBRARY_PATH ...很多的环境变量的列表
   PATH=/usr/include...   char* ps;
   CPATH=.                char* ps2;
   LIBRARY_PATH=.         char* ps3;
   ...                    ...
   组成一个字符指针数组来存储所有的环境变量
   字符数组：
       数组中每一个元素都是一个字符 char str[4];
   整型数组：
       数组中每一个元素都是一个整数 int arr[4];
   结构体数组：
       数组中每一个元素都是一个结构体变量struct S s[4]
   字符指针数组：
       数组中每一个元素都是一个字符指针 char* str[4];
注意：
    数组名表示数组的首地址，也就是数组中第一个元素的地址，并且是个常量不可改变

   通过使用字符指针数组存放所有的环境变量以及值，通过最后一个元素的值为NULL来代表字符数组的结束，通过一个全局变量environ来指向环境表的首地址，从而访问所有的环境变量，使用extern char** environ进行访问
   
2.2 环境变量相关的函数
(1) getenv函数
    #include <stdlib.h>
    char *getenv(const char *name);
函数功能：
    根据参数指定的环境变量名获取对应的环境变量值，如果
    不存在则返回NULL

(2)setenv函数
   #include <stdlib.h>
   int setenv(const char *name, const char *value, int overwrite);
第一个参数：环境变量名
第二个参数：环境变量名所对应的值
第三个参数：是否修改  非0则修改，0则不修改
返回值：成功返回0，失败返回-1
函数功能：增加/修改环境变量的值 

(3)putenv函数
  #include <stdlib.h>
  int putenv(char *string);
函数功能：
   根据参数进行增加/修改环境变量，参数的格式：name=value，成功返回0，失败返回非0 

(4)unsetenv函数
   int unsetenv(const char *name);
函数功能：
   根据参数指定的环境变量名称从环境表中删除，成返回0，失败返回-1

(5)clearenv函数
   int clearenv(void);
函数的功能：
   清空环境表中所有环境变量值，成功返回0，失败返回非0

3.3 主函数原型
  int main(int argc,char* argv[],char** env)
  {
      return 0;
  }
第一个参数：传递给main函数的参数个数
第二个参数：字符指针数组，数组中每一个元素都是一个指
          针，存储每一个实参的地址   
第三个参数：环境表的首地址

比如：
    a.out 张三 李四 王麻子
    argc = 4
    argv用于存储上述字符串的首地址
    env 表示带进来环境表的首地址

    cp 源文件 目标文件
    a.out 源文件 目标文件

    echo 回显
    echo $SHELL  获取shell的类型然后显示出来

4.内存管理
4.1 程序和进程的概念
   程序:一般表示代码经过编译链接的产物，是硬盘上的文件
   进程:运行在内存中的程序

4.2 进程中内存区域的划分
如：
    int g_num; //全局变量 0  BSS段
    int main(void)
    {
         int num; //局部变量  随机数 栈区 
         return 0;
    } 

(1)代码区：存放 代码/函数 的区域
(2)只读常量区：存放常量字符串和const修饰的全局变量
               “hello”  
(3)全局区：存放全局变量，static修饰的局部变量       
(4)BSS段：未初始化的全局变量，BSS段在main函数执行之前
        进行清零处理
(5)堆区：malloc/calloc/realloc/...申请的内存区域，内存
        空间需要程序员手动申请和手动释放
(6)栈区：存放的局部变量、块变量(包括函数的形参),const
        修饰的局部变量

4.3 内存区域的排序
   6个内存区域的地址从小到大依次：代码区、只读常量区、全局区、BSS段、堆区、栈区

注意：
   一般而言，对于堆区的地址分配从小到大，对于栈区的内存区分配地址从大到小，防止内存重合以及灵活性

明日预报：
   (1)内存管理以及相关的函数
   (2)unix/linux系统的文件操作 






 




