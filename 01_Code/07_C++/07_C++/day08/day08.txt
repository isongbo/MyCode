一.虚函数
    1.1 概念
    加了 virtual 修饰的普通成员函数  
    1.2 举例
    
    1.3 虚函数对类型的影响
    只要类型中出现虚函数  则编译器会自动在类型
          的前四个多出一个指针类型的成员。
    这个指针就是 虚表指针 指向代码区中的一个地址。

二. 函数重写 （函数覆盖  overwrite） 
     2.1 概念  
     函数重写: overwrite
           子类中 提供了 和父类同名的 虚函数  这就是函数重写。
     名字隐藏: namehide
           子类中 提供了 和 父类同名的 数据 叫名字隐藏。
     函数重载: overload
            在同一作用域中 函数名相同  参数列表不同。
      2.2  举例 
     
三. 多态 
     3.1 概念 
     当父类对象的指针(引用)  指向子类对象时   并且调用
            父类中对应的虚函数 而且子类重写了这个虚函数
            则调用的表现是子类的。

     继承是构成多态的基础
     虚函数是多态的关键 
     函数重写 是必备条件 
     
     3.2  静态绑定 和 动态绑定
     静态绑定:在编译期确定调用的函数 地址
     动态绑定:在运行期 确定调用的函数地址 
     
     有虚函数的类型  会有一张虚函数表 （每个元素都是一个
           虚函数地址）,同类型的对象 共享虚函数表。
     当父类对象指针 指向子类对象时 调用的如果是 非虚函数
            则直接生成调用地址。如果调用的是虚函数 则先根据
            对象 获得虚函数表的地址 然后根据虚函数表中的函数
            地址进行相应的调用。   
 四.类型识别
     4.1 为什么要进行类型识别
     多态做到的效果是 类型通用 并且 结合虚函数 可以让对象
            作出相应的表现。
     但同时多态 会丢失个性。恢复个性 就需要类型识别。
     多态中动态绑定 比 静态绑定的效率低。
     4.2 typeid  可以获取类型或者对象的类型信息
        #include <typeinfo>
        typeid 返回 type_info 类型  这个类型提供了 一些运算
               符可以判断两个类型的或者两个对象的类型信息是否
               一致。
        typeid(类型)==typeid( 对象)
                             !=
                             name()  类型的名字     
      4.3  dynamic_cast<类型>(对象)
          适合具有多态性的父子类之间 
          如果转换成功 证明对象类型就是 对应的类型 并且返回
                对应的类型的地址, 如果转换失败 返回NULL。
 五. 抽象类 
      5.1  概念
      不能实例化的类 叫 抽象类,除此之外 抽象类和其它类
             没有任何区别。
      5.2 如何实现?
      只要在类型中出现一个纯虚函数 即可
      virtual   void  show()=0;                           
      子类如果不实现 纯虚函数 则子类自动成为抽象类
六. 虚析构函数 
     6.1 为什么要使用虚析构函数
     当父类对象的指针  指向子类对象时,如果释放指针
           对应的对象 则只会调用父类对应的析构函数。
           这时只要在父类的析构函数上 加一个virtual
           则调用的析构函数 是子类的,子类析构函数的
           调用必然触发父类析构函数的调用。
      6.2 举例       

七.异常   exception  (一种新的错误表达和处理形式)
    7.1 如何抛出异常
          throw  异常;
    7.2 程序只要抛出异常  
          则默认的处理方式 是调用terminate 函数终止程序 
    7.3 如何捕获异常    
           try{
                 可能会出现异常的代码
           }catch(类型1  e){
                 相应的处理
           }catch(类型2  e){
                 相应的处理
           }catch(类型3  e）{

           }catch(...){
                  // 其它的所有异常
           }
   7.4  异常的说明
        void   foo();  这个函数可能会抛出任何异常 
        void   foo()throw(int);  这个函数只抛出int异常
        void   foo()throw();      这个函数不抛出异常 
                                               如果抛出异常 则这些异常不
                                               可捕获。
         void  foo()throw(int,double,const char*);
                  这个函数可能会抛出int  或者 double  或者
                  const  char*
        
                      







   


                 





  