一.静态成员
     1.1 静态函数 调用 非静态成员
           通过自己传入访问的对象地址

     1.2  单例模式 
     (程序中这个类型的对象只有一个 )
     类   访问权限  构造  拷贝构造  引用  静态 
二.成员指针 
    2.1 成员变量指针
         2.1.1 概念 
         指向成员变量的指针  这个成员变量权限控制
         2.1.2  语法
         struct   Date{
                int   year;
                int  month;
                int  day;  
         }; 
        /* 定义成员变量指针 */
         成员变量的类型  类名::*   指针名;          
        /* 赋值 */
         指针名=&类名::成员变量名;  
        /* 成员指针解引用  对象.*成员指针名 
            指针对象->*成员指针名  */
         Date    date;
         date.*成员指针名;
         Date   *date=new Date();
         date->*成员指针名;
         2.1.3  本质
         成员变量指针的本质 就是记录对象首地址的偏移量 
           
     2.2 成员函数指针
        2.2.1 语法 
        struct   Date{
                int   year;
                int  month;
                int  day; 
                int  getYear(){
                       return  year;
                }
                int  getMonth(){
                       return  month;
                }  
         };  
         定义一个成员函数指针 
          int  (Date::*pfun)(); 
         成员函数指针赋值 
         pfun=&Date::getYear;
         成员函数指针 解引用
         Date  date; 
         (date.*pfun)();  
         Date  *pdate=new Date();
        （pdate->*pfun）();         

         2.2.2  举例
        
三.运算符重载 
    3.1 什么是运算符重载
    一种函数的特殊表现形式 
    3.2 举例
    写一个分数类   
            特征: 分子 分母
            行为:
            构造函数 参数默认值 0,1
            显示一个分数  格式: 分子/分母        
    3.3  二元运算符的解析规则
    L#R     比如  a*b    
           编译器先去L对象对应的类型中找一个成员函数叫
                  operator#(R)  如果找不到 就去全局找一个函数
                  operator#(L,R)  最后判断调用最合适的一个。
    能是成员 就写成成员形式 不能是成员才考虑全局
    
    3.4 友元函数 
    可以获取类的私有成员的访问权利 
    不受类的访问权限控制

     成员函数   静态成员函数  友元函数    
           访问类的私有数据 
           受类的访问权限控制 
           必须使用对象调用 
     成员具备三点  静态函数具备前两点  友元具备第一点 
     3.5 输入输出运算符的重载 
     Fraction   fa(1,2);    fa.show();
     cout << fa;  
     cout ----- ostream&  这个类型的对象不能复制 不能加 
                      const修饰
     L#R    
        编译器先去L对象对应的类型中找一个成员函数叫
                  operator#(R)  如果找不到 就去全局找一个函数
                  operator#(L,R)  最后判断调用最合适的一个。
        
     3.6 包装一个整数类    
         特征: 
                private:
                int  data
         行为:
                要求支持  +   -   *   /
                还可以支持判断相等  ==
                还要输入 输出   >>   <<
     3.7 一元运算符的重载规则
      ~    ！   -    ++  -- 
    Integer  a=10;
    ~a;
    !a;
    #O    编译器先去 O对象对应的类型中找一个成员函数
             叫operator#()  如果没有找到就去全局找一个
             全局函数 叫 operator#(O)               
    O#     编译器先去 O对象对应的类型中找一个成员函数
             叫operator#(int)  如果没有找到就去全局找一个
             全局函数 叫 operator#(O,int)       

   
                  








     