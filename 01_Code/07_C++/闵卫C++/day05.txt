程序员写：
Student s ("张飞", 25);
编译后的机器指令相当于如下：
从栈内存中分配sizeof (Student)字节
调用Student::Student ("张飞", 25)函数初始化
程序员写：
Student* s = new Student ("张飞", 25);
被编译器处理为：
Student* s = malloc (sizeof (Stduent));
调用Student::Student ("张飞", 25)函数初始化(s->Student ("张飞", 25)/
     Student::Student (s, "张飞", 25))
一、C++对象模型
class Student {
public:
    Student (char const* name, int age) {
        strcpy (m_name, name);
        m_age = age;
    }
    void print (void) {
        cout << m_name << "，" << m_age
            << endl;
    }
private:
    char m_name[256];
    int m_age;
};
Student s1 ("张飞", 25);
1.C++的对象模型和C的结构模型没有任何区别，包括成员的布局，以及对齐补齐的规则。
2.对象中只有成员变量，没有成员函数。类的成员变量在该类的每个对象中都一份独立的拷贝。但是类的成员函数只有一份，且为该类的所有对象共享。
3.为了在一个函数中区分出不同的调用对象，编译器会为每个成员函数提供一个隐藏的指针参数——this指针——指向调用该成员函数的对象。在成员函数中对所有成员变量的访问，以及对其它成员函数的调用，实际上都是通过this指针完成的。
4.类的构造函数中同样具有this指针参数，指向这个正在被构造的对象。
class B;
class A {
    B m_b;
};
class B {
    A m_a;
};
A a; sizeof (A) ?
5.显式使用this指针的场合
1)解决成员变量的名字冲突；
2)从成员函数中返回调用对象的自引用；
3)通过成员函数实现对象间的交互；
4)在成员函数函数销毁调用对象自身。
二、常函数
1.在类成员函数的参数表之后，函数体的左花括号之前，加上const关键字，该成员函数的this指针即具有常属性，这样的成员函数被称为常函数。
2.在常函数内部，因为this指针被声明为常量指针(即目标只读的指针)，所以无法修改成员变量的值，除非该成员变量被mutable关键字修饰。
3.常对象只能调用常函数，非常对象既可以调用非常函数也可以调用常函数。原型相同的常函数和非常函数可以构成重载关系。
三、析构函数
1.析构函数是类的特殊的成员函数
1)析构函数的函数名就是在类名前面加“~”;
2)析构函数没有返回类型；
3)析构函数没有参数
4)析构函数不能重载
2.析构函数在对象被销毁时自动调用
1)局部对象的析构函数由其所在最小作用域的右花括号调用；
2)堆对象的析构函数被delete运算符调用；
3)全局对象的析构函数，被进程加载器调用。
3.缺省析构函数
如果一个类没有定义析构函数，编译器提供一个缺省析构函数。该函数对于基本类型的成员变量什么也不做，而对于类类型的成员变量，则会调用其相应类型的析构函数。
四、拷贝构造和拷贝赋值
1.缺省方式的拷贝构造和拷贝赋值，对包括指针在内的基本类型成员变量按字节复制，导致浅拷贝问题。
2.为了获得完整意义上的对象副本，必须自己定义拷贝构造函数和拷贝赋值运算符函数，针对指针型成员变量做深拷贝。
3.拷贝赋值运算符函数的实现
1)避免自赋值；
2)分配新资源；
3)释放旧资源；
4)拷贝新内容；
5)返回自引用。

