一、重(chong)载(overload)
1.同一个作用域中，函数名相同，参数表不同的函数，构成重载关系。
2.调用函数时，根据实参与形参的类型匹配情况，选择一个确定的重载版本，这个过程称为重载解析。
3.通过函数指针指向具有重载关系的函数，所选择的重载版本由该函数指针的类型决定。
4.C++换名：C++编译器会按照一定的规则，将函数的参数表信息与函数的原始名混合编码，形成一个新的函数名。因此具有重载关系的函数，虽然其原始名一样，但是因为其参数表的不同，最后编译生成的实际函数名是不同的。
5.通过extern "C"可以要求C++编译器按照C的方式处理函数接口，即不换名，当然也就重载。
extern "C" int add (int a, int b);
extern "C" int sub (int a, int b);
或
extern "C" {
int add (int a, int b);
int sub (int a, int b);
}
如果包含extern "C"声明指定符的文件也需要被C编译器处理，为了防止C编译器因为无法识别extern "C"而导致报错：
#ifdef __cplusplus
extern "C" {
#endif
...
#ifdef __cplusplus
}
#endif
只有在C++编译器中__cplusplus宏才有定义，在C编译器中该宏无定义。
二、缺省参数
1.可以为函数的参数指定缺省值，调用函数时若未指定实参，则与该实参相对应的形参取缺省值。
2.函数的缺省参数是在编译阶段解决的，因此只能用常量、常量表达式或者全局变量等非局部化数值作为缺省参数。
3.如果函数的声明和定义分开书写，那么该函数的缺省参数只能出现在声明部分，定义部分不能指定缺省参数，但是可以通过注释提高代码的可读性。
4.如果函数的某一个参数带有缺省值，那么该参数后面的所有参数必须都带有缺省值。
5.不要因为使用缺省参数而导致重载歧义。
三、哑元
1.只指定类型而不指定名称的函数参数，谓之哑元。
2.哑元主要应用于版本升级过程中的向下兼容和特殊的操作符重载等场合。
四、内联
1.内联就是用函数已被编译好的二进制代码，替换对该函数的调用指令。
2.内联在保证函数特性的同时，避免了函数调用的开销。通过牺牲代码空间，赢得了运行时间。
3.内联会使可执行文件的体积和进程代码区的内存变大，因此只有频繁调用的简单函数才适合内联。稀少被调用的复杂函数，调用开销远小于其执行开销，由内联而获得的时间性能改善，不足以抵消空间性能的损失，故不适合内联。
4.递归函数不能内联。
5.通过inline关键字可以显式地请求编译器将某个函数处理为内联函数。
6.inline关键字仅仅表示一种对函数实施内联优化的期望，但该函数是否真的会被处理为内联，还要由编译器的优化策略决定。
7.多数现代编译器已经把内联作为一种缺省的优化机制，即使不是显式使用inline关键字，只要该函数符合内联优化的条件，编译器也会自动将其处理为内联函数。
五、动态内存分配
1.C中动态内存分配函数在C++中可以继续使用。
#include <cstdlib>
void* malloc (size_t size);
void* calloc (size_t nmemb, size_t size);
void* realloc (void* ptr, size_t size);
void free (void* ptr);
typedef unsigned int size_t;
2.new/delete运算符
int a = 0;
sizeof (a=5);
cout << a << endl; // 0
1)动态分配/释放单个变量
int* p = new int;
int* p = new int (123);
delete p;
2)动态分配/释放数组变量
int* p = new int[5] { ... };
delete[] p;
3)动态分配/释放高维数组
int (*prow)[4] = new int[3][4];
delete[] prow;
4)new在分配内存失败的情况下，不是返回NULL指针，而是抛出bad_alloc异常。
5)定位分配
new (地址) 类型[大小]
int* pn = new (pool) int (123);