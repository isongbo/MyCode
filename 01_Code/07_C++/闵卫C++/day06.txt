一、静态成员
1.属于类而非对象
1)静态成员变量不包含于对象实例中，具有进程级的声明周期
2)静态成员函数没有this指针，也没有常属性
3)静态成员函数只能访问静态成员（变量或函数），非静态成员函数既可以访问静态成员，也可以访问非静态成员。
2.静态成员也受访问控制的约束。
3.静态成员变量必须在类的外部定义或初始化，静态成员函数既可以在类的外部也可以在类的内部定义。
二、成员指针
通过类型的约束，表达指向类特定类型成员的指针。
三、操作符（运算符）重载
1.操作符标记
1)单目操作符：只有一个操作数的操作符。
-/++/--/&/*/->/!/~/()/类型转换，等等
2)双目操作符：有左右两个操作数的操作符。
算术运算：*///%/+/-
关系运算：>/>=/</<=/==/!=
逻辑运算：&&/||
位运算：&/|/^/<</>>
赋值和复合赋值：=/+=/-=/*=//=/...
下标运算：[]
int a[5] = { ... };
cout << a[3] << endl;
3)三目运算符：包含三个操作数的操作符。
条件运算：A ? B : C
2.操作符函数
1)在特定条件下，编译器有能力把一个由操作数和操作符组成的表达式，解释成为一个全局或者成员函数调用，该全局或者成员函数就被成为操作符函数。
复数(3+4i)
2)通过定义操作符函数，可以实现针对自定义类型的运算法则，并使之与内置类型具有一致的语义。
3.双目操作符
L#R
-> L.operator# (R)    // 成员，左调右参
-> ::operator# (L, R) // 全局，左一右二
1)运算类：左右操作数都可以为左值或右值，表达式的值必须是右值。
友元：可以通过friend关键字，把一个函数或者类声明为一个类友元。被声明有关的函数或类可以自由访问授权类的任何私有成员。友元声明可以位于授权类的公有/私有/保护任何区域，其效果都一样。
2)赋值类：右操作数可为左值或右值，但左操作数必须是左值，表达式的值是左值且为左操作数本身（而非副本）。
3)输入输出：左操作数是ostream/istream，右操作数对于输出可以是左值也可以是右值，对于输入只能是左值，表达式的值是左操作数本身。
Complex c1 (...);
Complex const c2 (...);
cout << c1; // cout.operator<< (c1)
                     // ::operator<< (cout, c1)
cout << c2;
cin >> c1;
cin >> c2; // ERROR
cout << c1 << c2 << endl;
4.单目操作符
#O/O#
->O.operator# ()
->::operator# (O)
1)运算类： 操作数既可以是左值也可以是右值，操作数在运算前后不发生变化，表达式的值是右值。
-x = 10; // ERROR
(0-x) = 10; // ERROR
2)前缀类：操作数为左值，表达式的值是左值，而且就是操作数本身。运算前后操作数的值会发生变化，表达式的值是变化以后的值。
3)后缀类：操作数为左值，表达式的值是右值，而是操作数运算之前的历史备份。运算前后操作数的值发生变化，表达式的值是变化以前的值。
5.三目操作符：无法重载
6.其它操作符：下标、函数、类型转换
7.不能重载的操作符
::/./.*/?:/sizeof/typeid
8.操作符重载的限制
1)所有操作数都是基本类型的不能重载
int a = 1, b = 1;
int c = a + b; // c = 10000 ?
2)无法改变操作符的优先级
z + x ^ y -> (z + x) ^ y
3)无法改变操作符的目数
4)无法发明新的操作符
**4
s1 @ s2
5)保持操作符的语义一致性
c1 + c2
str1 + str2