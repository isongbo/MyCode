一、继承的基本概念
1.共性和个性
学生：姓名、年龄、学号，吃饭、睡觉、学习
教师：姓名、年龄、工资，吃饭、睡觉、授课
---------------------------------------------
人类：姓名、年龄，吃饭、睡觉 - 共性
学生是人：学号，学习               - 个性
教师是人：工资，授课               - 个性
1)共性表达了不同类型事物之间共有的属性和行为。
2)个性则着意刻画每种类型事物特有的属性和行为。
2.超集与子集
1)超集体现了基于共性的一般。
2)子集体现了针对个性的特殊。
3.基（父）类和子类
1)基类表示超集，体现共性，描述共有的属性和行为。
2)子类表示子集，体现个性，描述特有的属性和行为。
4.继承与派生
基类：            人类(姓名、年龄、吃饭、睡觉)
          派生 V /     \ ^ 继承
子类：      学生      教师
    (学号、学习)     (工资、授课)
5.继承语法
class 子类 : 继承方式1 基类1, 继承方式2, 基类2, ... {};
class Human {...}; // 人类
class Student : public Human {...}; // 学生
class Teacher : public Human {...}; // 教师
class Assistant : public Student, public Teacher {...}; // 助教
继承方式：
public - 公有继承，最常见的继承方式
protected - 保护继承
private - 私有继承
6.公有继承的特点
1)皆然性：子类即基类
学生是人
教师是人
任何子类对象中都包含着它的基类子对象，而且通常位于子类对象的低地址部分。因此把一个指向子类对象的指针或者引用子类对象的引用转换为其基类类型可以隐式完成。实际上指这种转换就意味着把一个子类对象的基类部分看作是一个实际的基类对象。这种类型转换亦称向上造型。
2)可访问性
子类可以访问基类中哪些成员：公有成员、保护成员。基类的私有成员不能为子类所直接访问，但是在子类中存在。
3)隐藏性
如果在子类中定义和基类同名的标识符，那么子类中标识符就会隐藏基类中的标识符。除非通过作用域限定符显式地指明所访问的标识符源自基类。
4)传导性
当子类对象被构造、析构或者复制时，其基类子对象也需要同时被构造、析构或者复制。
A->B->C
当通过delete操作一个指向子类对象的基类指针时，实际被执行的是基类的析构函数，该函数不会调用（传导）子类的析构函数，子类所特有动态资源将形成内存泄漏。
7.继承方式对访控属性的影响
考虑继承方式：通过子类访问其所继承。
class A { void foo (void) { ... } };
class B : public A {
    void bar (void) {
        foo(); //直接访问基类，不考虑继承方式
    }
};
class C : public B {
    void bar (void) {
        foo (); //通过子类B访问其从基类A中
                    //继承的foo，需要考虑继承方式
    }
};
int main (void) {
   B b;
   b.foo (); // 通过B访问其继承的foo
                  // 需要考虑继承方式
   return 0;
}
基类  公子  保子  私子
公有  公有  保护  私有
保护  保护  保护  私有
私有  私有  私有  私有
8.私有继承和保护继承
class DCT { // $1000
public:
    void codec (void);
};
class Jpeg : protected DCT {
public:
    void render (void) {
        ... codec () ...
    }
};
class Jpeg2K : public Jpeg {
};
// $1
class PDF : public Jpeg {
public:
    void show (void) {
         ... render () ...
         ... codec () ... // ERROR
    }
}; 
私有继承亦称实现继承，其目的在于将基类中的公有和保护成员，与子类中私有化，防止其通过子类扩散。但是，如果希望在子类的子类可以继续访问这些成员，而只是限制在子类外部的访问，则可以将子类从基类的继承方式设置为保护继承。
保护和私有继承不具有皆然性。
二、多重继承
1.一个子类从多个基类中派生。
电话   媒体播放器   计算机
       \          |         /
           智能手机
2.钻石继承问题
    A
  /   \
B     C
  \   /
    D
    A
  / | \
B  C  D
 \ / \ /
  E   F
   A
  /  \
B    D
|      |
C     |
  \   /
    E
1)一个子类继承自多个基类，而这些基类又源自共同的祖先(公共基类)，这样的继承结构称为钻石继承。
2)派生多个中间子类的公共基类子对象，在继承自多个中间子类的汇聚子类对象中，存在多个实例。
3)在汇聚子类中，或通过汇聚子类对象，访问公共基类的成员，会因继承路径的不同而导致不一致。这种现象称为钻石继承问题。
3.虚继承
1)通过虚继承，可以保证公共基类子对象在汇聚子类对象中，仅存一份实例，且为多个中间子类对象所共享。
2)为了表示虚继承，需要在继承表中使用virtual关键字。
3)一般而言，子类的构造函数不能指定间接基类的构造方式，但是一旦这个间接基类被声明为虚基类，它的所有子类，无论是直接子类还是间接子类，都必须显式地指明该公共基类子对象的构造方式，否则系统将按照缺省方式构造该子对象。