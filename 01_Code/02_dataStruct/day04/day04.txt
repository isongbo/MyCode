复习：
1.堆栈
1.1 概念
   具有后进先出特性的数据结构, LIFO(Last In First Out)
1.2 基本操作
   创建 销毁 入栈 出栈 ...
1.3 使用顺序存储结构实现堆栈的操作
    堆栈的成员中：使用数组来进行操作
1.4 使用链式存储结构实现堆栈的操作
    堆栈的成员中：使用链表

2.队列
2.1 概念
   具有先进先出特性的数据结构  FIFO(First In First Out)
2.2 基本操作
   创建  销毁  入队  出队 ....
2.3 使用顺序存储结构实现队列操作
    本质就是操作数组
2.4 使用链式存储结构实现队列操作
    本质就是操作链表
作业：
-------------------------------------------------------
今天内容：
   (1)树和二叉树 
   (2)4种排序算法
   (3)2种查找算法

1.树的概念
  线性结构:体现元素之间存在一对一的关系
如：数组、链表、栈、队列 

  树形结构:体现元素之间存在一对多的关系
如：树 家谱 
  
   树其实就是由 根 和 很多分支组成的,当然树可以是空树;
也就是由根节点 和 若干个分支 组成,其中多个分支之间没有交叉,其中每一个分支又可以看做一个小树,叫做子树 
   其中每一个节点的组成：元素 + 若干个指针
 
2.二叉树
2.1 基本概念
   最多只有两个分叉/分支的树 叫做二叉树
   对于一颗二叉树来说，如果除了最下面的一层节点之外，其他每一层上的所有子节点都是两个，则称为满二叉树,其中最下面一层没有任何子节点的节点，叫做叶子节点
   对于一棵二叉树来说，如果没有子节点没有摆满,依次摆放二叉树，没有跳过的分支，最下面的一层可以不满，其他层都是摆满,但是最下面一层的子节点必须摆放在左侧，这样的二叉树叫做完全二叉树
   二叉树的节点组成： 元素 + 两个指针(分别指向左右子节点，也就是左右子树)

2.2 基本特征
(1)每一个节点最多有两个子节点,而每一个子节点又可以有两个子节点,分别叫做左子树和右子树
(2)对于一个二叉树来说,只有一个根节点,而每一个子节点有且只有一个父节点
(3)具有递归的结构,也就是一个二叉树可以拆分位很多的小二叉树，一般采用递归方式进行处理:
   处理(二叉树)
   {
       if(是否为空) { 如果为空，直接处理;}
       else
       {
           处理根节点;
           处理左子树; => 递归
           处理右子树; => 递归
       }
   }

2.3 有序二叉树
   一般来说，左子树 < 根节点  <= 右子树,满足此规律的二叉树叫做有序二叉树，又叫做二叉查找树

如：
   50  20  30  60  40  70  10  80  90 

2.4 二叉树的遍历
(1)先序遍历，又叫做先根遍历
   根节点  ->  左子树  ->  右子树
(2)中序遍历，又叫做中根遍历
   左子树  ->  根节点  ->  右子树(掌握) 
(3)后序遍历, 又叫做后根遍历
   左子树  ->  右子树  ->  根节点

练习：
   45  20  30  60  25  75  40  15  90
组装有序二叉树：
       45
     /   \
   20     60
 /   \      \
15   30     75
    /  \     \
   25  40    90
先序遍历： 45 20 15 30 25 40 60 75 90
中序遍历： 15 20 25 30 40 45 60 75 90
后序遍历： 15 25 40 30 20 90 75 60 45 

2.5 基本操作
   创建  销毁  插入节点  删除节点  遍历 ...
如：
   void fa(int* pi)
   {
        *pi = 200;
   }
   int main(void)
   {
       int num = 20;
       //fa(num); //值传递 num = 20;
       fa(&num); //址传递  num = 200;
       return 0;
   }

作业：
   把二叉树的功能代码看懂就行了
明日预报：
   (1)4种排序算法
   (2)2种查找算法
   (3)UC课程介绍
-------------------------------------------------------
1.常见的排序算法
1.1 冒泡排序算法
(1)算法流程
   a.比较相邻位置的元素,如果第一个比第二个大，则交换两个元素的位置
   b.对每一对相邻位置的元素重复上述过程，从开始的第一对到结尾的最后一对元素,经过这一步，最后元素将是最大值
   c.针对所有的元素重复以上步骤，除了最后一个
   d.持续对越来越少的元素重复以上步骤，直到没有元素需要交换为止

(2)算法评价
   平均时间复杂度 O(N^2),稳定,对样本的有序性比较敏感

1.2 插入排序算法
(1)算法流程
   a.从第一个元素起，该元素可以认为已经有序
   b.从第二个元素起,取出该元素与已经有序的元素从后向前进行比较
   c.如果左边的元素大于取出的元素，则将左边的元素赋值到下一个位置上
   d.如果左边的元素小于取出的元素,则将取出的元素插入到左边元素之后
   e.重复上述过程，直到处理完所有元素为止 

(2)算法评价
   平均时间复杂度 O(N^2),稳定,对样本有序性比较敏感,但是赋值的次数比冒泡排序少,因此略优于冒泡排序

1.3 选择排序
(1)算法流程
   a.从第一个元素起，依次取出该元素，并且假定该元素是最小数，记录该元素的下标到min
   b.使用所记录下标min对应的最小数依次与后面的元素进行比较,如果找到比min所对应元素还小的数，则修改min的值
   c.重复第二步，直到与后面元素依次比较完毕,让最开始假定的最小数与下标min所对应的元素进行交换
   d.重复上述步骤，直到所有元素都排序完毕为止   

(2)算法评价
   平均时间复杂度 O(N^2),不稳定,对数据的有序性不敏感,
虽然比较的次数比较多，但是交换的次数比较少,因此略优于冒泡排序

1.4 快速排序
(1)算法流程
   a.使用两个变量i,j分别记录左边元素下标和右边元素下标,根据左边元素和右边元素的下标计算中间元素的下标，使用中间元素作为基准值，单独保存一份
   b.分别使用左边元素和右边元素与基准值进行比较，将比基准值小的元素放到左边，将比基准值大的元素放到右边，等于基准值的元素可以放在任意一边，一般默认放在右边
   c.采用递归的方式分别对基准值左边的元素和基准值右边的元素进行分组，重复以上过程

(2)算法评价
   平均时间复杂度 O(NLogN),不稳定,如果每次分组都能做到均匀分配，排序速度会很快

2.查找算法   
2.1 线性查找(顺序查找)
(1)算法流程
   从第一个元素起,依次取出每一个元素和目标元素进行比较,直到找到与该元素相等的元素，或者与所有元素比较完毕为止

(2)算法评价
   平均时间复杂度 O(N),对样本的有序性没有要求

2.2 二分查找(折半查找)  
(1)算法流程
   首先假设这组数据是有序的，假设从小到大排列的,选择中间元素与目标元素进行比较,如果相等则直接返回,也就是查找成功;如果中间元素小于目标元素,则去中间元素的右侧进行查找，重复上述过程;如果中间元素大于目标元素，则去中间元素的左侧进行查找，重复上述过程;直到查找成功，或者所有元素比较完毕

(2)算法评价
   平均时间复杂度 O(logN),要求样本元素必须有序








   




















  













 





 






   
  
  



















  







