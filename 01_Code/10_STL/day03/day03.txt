三、类模板
12.缺省模板参数
1)模板的参数可以带有缺省值，实例化该模板是如果不提供对应于该模板参数的实参，则该模板参数取其缺省值。
2)如果模板的某个参数带有缺省值，那么该参数后面的所有模板参数必须都带有缺省值。
3)函数模板在C++98标准中不能带有缺省模板参数，但是在C++2011标准中可以。当隐式推断的类型和模板参数的缺省值不一致的情况下，隐式推断优先。函数模板的调用参数(圆括号中参数)无论在98还是2011标准中，总是可以带有缺省参数的。
4)函数模板调用参数的缺省值不参与对模板参数类型的隐式推断。
5)与函数的缺省参数不同，模板的后面参数的缺省值可以引用前面的参数。
四、模板的非类型参数
传递给模板的参数除了类型参数以外，也可以是数值形式的参数，谓之非类型参数。作为传递给模板非类型参数的实参，可以是常量、常量表达式或者带有常属性(const)的变量，但是不能同时具有挥发性(volatile)。
五、嵌套依赖
如果在模板中需要使用某种依赖于模板参数的内部类型，需要在该类型前面加上typename关键字，避免编译器将该内部类型解释为静态成员变量，导致编译错误。
         class - 声明类
                  \ 声明模板
                  / 的类型参数
typename - 解决嵌套依赖
无论是声明模板的类型参数，还是解决嵌套依赖，都不能使用struct关键字。
六、模板依赖
如果在模板中需要访问某种依赖于模板参数的内部模板，需要在该内部模板的前面加上template关键字，避免编译器将该内部模板的模板参数表解释为小于号和大于号，导致编译错误。
七、继承依赖
在子模板中访问依赖于模板参数的基模板中的成员，需要显式注明基模板的作用域或者显式使用this->（非静态成员函数），否则编译器只会在子模板和全局域中查找所访问的名称，而不会到基模板中查找。
八、模板型模板成员
1.模板型成员变量
2.模板型成员函数
3.模板型成员类型
九、向模板派生
通过为子类模板指定不同的基类类型实参，可以让同一个子类从不同的基类派生。在子类中完成共有的任务，通过不同的基类表示不同的特征。
十、模板型模板参数
类模板的模板参数本身又可以是个模板，但是注意该模板参数的声明不能使用typename关键字，而要写成template<...> class形式。
函数模板的模板型模板参数：标准C++不支持，但是GNU编译器提供支持。
十一、零初始化
基本类型不存在缺省构造函数，未被显式初始化的局部变量或者局部对象的成员变量都具有一个未定义的初始值。如果希望模板中所有参数化类型的变量，无论是类类型还是基本类型，都能以缺省方式得到初始化，就必须对其进行显式缺省构造。
T t = T ();
对于类模板，可以在其缺省构造函数的初始化表中，显式初始化其各个成员变量，无论是类类型的还是基本类型的。
A::A (void) : m_t () {}
十二、模板虚函数与虚模板函数
1.类模板中可以定义虚函数，而且和普通类一样，也可以表现出多态性。
2.模板型成员函数不可以是虚函数。
十三、静态多态
多态的本质就是通过一种类型的一种方法产生不同的外观。
十四、编译模型
1.分离模型：每个C或C++源文件都是被单独编译的。编译器在编译模板定义文件时所生成的模板内部表示，在编译对该模板进行实例化的代码时，已经被销毁了。因此所有基于模板实例的类和函数，编译器只能假设它们被定义在其它模块中，并产生一个指向该定义的引用，期待链接器能在日后解决此问题。但事实上，由于模板的内部表示并没有真正化身为可执行指令代码，链接器最终报告“未定义的引用”错误。
2.包含模型：只要在模板的声明文件尾部包含模板的定义文件，预处理器就能够将模板的声明、定义和实例化代码扩展到同一个编译单元中，保证编译器能够在看到模板被实例化的同时找到相应的内部表示，生成正确的二进制指令，链接成功。
包含模型的缺点：延长编译时间、模板定义文件必须公开。
3.实例模型：显式实例化指示符是由template关键字和紧接其后的实例化实体（类、函数、成员函数等）的声明组成。该声明是一个用模板实参完全替代模板形参之后的声明。编译器会根据该声明生成针对每个具体实例的二进制指令。保证链接正确。
实例模型的优点：编译速度快、模板的定义文件不公开。
实例模型的缺点：实例化的类型总是有限的，不能保证模板的通用性，而且必须跟踪每个需要实例化的类型，对于大型项目而言会增加开发成本。
4.导出模型：通过export关键字将模板声明为导出，编译器会将该模板的内部表示缓存在某处，等到编译器看到对该模板的实例化代码时，再从缓存中读回模板的内部表示，结合模板实参，生成二进制指令代码，完成链接。
优点：编译速度快，模板定义不公开，实例化类型不受限制。
缺点：绝大多数编译都不支持该模型。
C++2011以废除此特性。
十五、预编译头
容器、迭代器、泛型算法