模板和标准模板库(STL)
一、模板起源
1.类型决定了无法为类型无关的算法和数据结构编写一般化的实现。
2.通过参数宏可以摆脱来自类型的约束，但同时也引入了类型不安全的风险。
3.借助预编译器扩展宏形式的函数样板，生成针对具体类型的具体函数，既保证了函数调用的类型安全，同时为算法和数据结构提供了一般化的表示方法。
二、函数模板
1.定义
template<typename 类型形参1, typename 类型形参2,
    ...> 返回类型 函数模板名 (调用形参表) { ... }
例如：
template<typename A, typename B>
A foo (B b) {
    A a;
    return a;
}
2.使用
函数模板名<类型实参1, 类型实参2, ...> (调用实参表);
例如：
int i = foo<int, string> ("hello");
char c = foo<char, double> (3.14);
3.两次编译
当编译器第一次”看到“函数模板时，首先做与类型无关的语法检查，其次生成针对该模板的内部表示。当编译器”看到“调用该函数模板的代码时，用所提供的类型实参，与先前生成内部表示中的类型形参结合，做与类型相关的语法检查，若检查通过则编译该具体函数为二进制机器指令，并生成相应的函数调用代码。
4.隐式推断
如果函数模板的调用参数的类型相关于函数模板的模板参数，那么在调用该函数模板是即使不显式提供模板参数，编译器也可以根据调用参数的类型隐式推断出正确的模板参数。
不能隐式推断的场合：
1)不是全部模板参数都与调用参数的类型相关；
2)返回类型不参与隐式推断；
3)隐式推断不能和隐式转换同时存在。
函数模板的模板参数可以部分显式指定，部分隐式推断，但是隐式推断的模板参数必须位于模板参数表的后部。