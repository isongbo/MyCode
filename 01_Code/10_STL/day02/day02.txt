二、函数模板
5.重载
1)同一个作用域中，函数名相同参数表不同的函数模板和普通函数可以构成重载关系。
2)重载解析的规则与普通函数一样：完全匹配->常量转换->升级转换->标准转换->自定义转换->省略号匹配。
3)类型具体化优先：编译器总是优先选择类型具体化程度最高的重载版本。
注意事项见overload.cpp中注释。
三、类模板
1.将类中的成员变量、成员函数、成员类型甚至基类中所出现的类型参数化，就是所谓的类模板。
2.定义
template<typename 类型参数1, typename 类型参数2,
    ...> class 类模板名 { ... };
3.使用
类模板名<类型实参1, 类型实参2, ...>
^^^^^^^^^^^^^^^^^^^^^^ - 表示一个具体类型
4.两步实例化
             编译器          处理器
类模板 -实例化> 类 -实例化-> 对象
             编译期(CT)  运行期(RT)
类模板不支持隐式推断。
5.类模板中的任何成员函数（包括构造函数、析构函数、运算符函数、甚至静态函数）都是函数模板。如果将其定义放在类模板的外部，必须按照函数模板的语法进行定义。
6.按照严格的语法，类模板中所有引用类型的场合都应该加上模板参数表“<类型形参1, 类型形参2, ...>”，但是如果只是作为类名引用，如构造和析构函数名，则不需要加参数表。
7.一个具体类型能否实例化一个给定类模板，取决于那些用到的模板功能是否得到该类型的支持，而没有用到的模板功能不需要在该类型中提供任何支持。
8.类的静态成员变量，每个类只有一份拷贝，该类的所有对象共享这一份拷贝。类模板的静态成员变量，每个实例化类都有一份独立的拷贝，该实例化类的所有对象共享该份拷贝。
9.类模板的递归实例化
一个类模板的实例化类就相当于一个具体类型，可以被继续用于实例化任何类模板，当然也包括该类模板自身。用一个类模板的实例化类实例化该模板自身，就被称为递归实例化。类模板的递归实例化经常被用于构建在空间上具有递归特征的数据结构（如二叉树、多维数组、十字链表）。
10.类模板的特(例)化
1)全类特化
类模板的通用版本对于某些特殊的具体类型可能并不适用或者性能不佳，这时可以用该具体类型对类模板做全类特化，即定义一个只针对具体类型的具体类，以实现正确的或者具有更好性能的替代实现。
2)成员特化
可以只针对类模板的个别成员函数进行特化，其它成员函数仍然使用通用版本中的实现，但是一定要保证特化版本的函数原型要与通用版本严格一致。
11.类模板的局部(偏)特化
只针对类模板的部分模板参数取特定类型，或者类模板的模板参数具有特定的关系或属性，所做的特化被称为类模板的局部特化。
匹配顺序：完全特化>      局部特化         >通用版本
                                 具体类型>一般类型
auto_ptr
注意：函数模板(包括类模板的成员函数)不能做局部特化。